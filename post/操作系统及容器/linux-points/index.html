<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="generator" content="Hugo 0.65.0-DEV" />

  <title>Linux Points &middot; Blog</title>

  <meta name="description" content="" />

  
  <meta property="og:locale" content="en-us"/>

  
  <meta property="og:image" content="https://antoniodc-aaa.github.io/images/name.jpg">

  
  <meta property="og:site_name" content="Blog"/>
  <meta property="og:title" content="Linux Points"/>
  <meta property="og:description" content="Linux Points  能够简单使用cat，grep，cut等命令进行一些操作； 文件系统相关的原理，inode 和block等概念，数据恢复； 硬链接与软链接 进程管理相关，僵尸进程与孤儿进程，SIGCHLD  文件系统 分区与文件系统 对分区进行格式化是为了在分区上建立文件系统。一个分区通常只能格式化一个文件系统，但是磁盘阵列技术可以将一个分区格式化多个文件系统"/>
  <meta property="og:url" content="https://antoniodc-aaa.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%8A%E5%AE%B9%E5%99%A8/linux-points/"/>
  <meta property="og:type" content="article"/>
  <meta property="article:published_time" content="2019-08-15T08:08:30&#43;0800"/>
  <meta property="article:modified_time" content="2019-08-15T08:08:30&#43;0800"/>
  <meta property="article:author" content="Antonio.D.C">
  
  
  

  <script type="application/ld+json">
  {
    "@context" : "http://schema.org",
    "@type" : "Blog",
    "name": "Blog",
    "url" : "https://antoniodc-aaa.github.io/",
    "image": "https://antoniodc-aaa.github.io/images/name.jpg",
    "description": "You only live once !"
  }
  </script>

  
  <script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "name": "Linux Points",
    "headline": "Linux Points",
    "datePublished": "2019-08-15T08:08:30\x2b0800",
    "dateModified": "2019-08-15T08:08:30\x2b0800",
    "author": {
      "@type": "Person",
      "name": "Antonio.D.C",
      "url": "https://antoniodc-aaa.github.io/"
    },
    "image": "https://antoniodc-aaa.github.io/images/name.jpg",
    "url": "https://antoniodc-aaa.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%8A%E5%AE%B9%E5%99%A8/linux-points/",
    "description": "Linux Points  能够简单使用cat，grep，cut等命令进行一些操作； 文件系统相关的原理，inode 和block等概念，数据恢复； 硬链接与软链接 进程管理相关，僵尸进程与孤儿进程，SIGCHLD  文件系统 分区与文件系统 对分区进行格式化是为了在分区上建立文件系统。一个分区通常只能格式化一个文件系统，但是磁盘阵列技术可以将一个分区格式化多个文件系统"
  }
  </script>
  


  <link type="text/css"
        rel="stylesheet"
        href="https://antoniodc-aaa.github.io/css/print.css"
        media="print">

  <link type="text/css"
        rel="stylesheet"
        href="https://antoniodc-aaa.github.io/css/poole.css">

  <link type="text/css"
        rel="stylesheet"
        href="https://antoniodc-aaa.github.io/css/hyde.css">

  
<style type="text/css">
  .sidebar {
    background-color: #fc21803;
  }

  .read-more-link a {
    border-color: #fc21803;
  }

  footer a,
  .content a,
  .related-posts li a:hover {
    color: #fc21803;
  }
</style>



  <link type="text/css" rel="stylesheet" href="https://antoniodc-aaa.github.io/css/blog.css">

  <link rel="stylesheet"
        href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700&display=swap">

  <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css"
        integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk="
        crossorigin="anonymous" />

  <link rel="apple-touch-icon-precomposed"
        sizes="144x144"
        href="/apple-touch-icon-144-precomposed.png">

  <link rel="shortcut icon" href="/favicon.png">

  
  </head>
<body>
  <aside class="sidebar">
  <div class="container">
    <div class="sidebar-about">
      
        
        <div class="author-image">
          <img src="https://antoniodc-aaa.github.io/images/name.jpg" class="img-circle img-headshot center" alt="Profile Picture">
        </div>
        
      

      <h1>Blog</h1>

      
      <p class="lead">You only live once !</p>
      
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li>
          <a href="https://antoniodc-aaa.github.io/">Home</a>
        </li>
        <li>
          <a href="/post/"> Posts </a>
        </li><li>
          <a href="/tags/"> Tags </a>
        </li><li>
          <a href="/about/"> About </a>
        </li>
      </ul>
    </nav>

    <section class="social-icons">
      
      <a href="https://github.com/" rel="me" title="GitHub">
        <i class="fab fa-github" aria-hidden="true"></i>
      </a>
      
    </section>
  </div>
</aside>


  <main class="content container">
  <div class="post">
  <h1>Linux Points</h1>

  <div class="post-date">
    <time datetime="2019-08-15T08:08:30&#43;0800">Aug 15, 2019</time> · 2 min read
  </div>

  <h1 id="linux-points">Linux Points</h1>
<ul>
<li>能够简单使用cat，grep，cut等命令进行一些操作；</li>
<li>文件系统相关的原理，inode 和block等概念，数据恢复；</li>
<li>硬链接与软链接</li>
<li>进程管理相关，僵尸进程与孤儿进程，SIGCHLD</li>
</ul>
<h2 id="文件系统">文件系统</h2>
<h3 id="分区与文件系统">分区与文件系统</h3>
<p>对分区进行格式化是为了在分区上建立文件系统。一个分区通常只能格式化一个文件系统，但是磁盘阵列技术可以将一个分区格式化多个文件系统</p>
<h3 id="组成">组成</h3>
<p>inode：一个文件占用一个inode，记录文件的属性，同时记录此文件的内容所在的block编号</p>
<p>block：记录文件的内容，文件太大时，会占用多个block。</p>
<p>除此之外还包括：</p>
<p>superblock：记录文件系统的整体信息，包括inode 和block 的总量、使用量、剩余量，以及文件系统的格式与相关信息</p>
<p>block bitmap：记录block是否被使用的位图</p>
<h3 id="文件读取">文件读取</h3>
<p>对于Ext2 文件系统，当要读取一个文件的内容时候，先在inode中查找文件内容所在的block，然后把所有的block的内容读出来。</p>
<p>而对于FAT文件系统，没有inode，每个block中存储着下一个block的编号。</p>
<h3 id="磁盘碎片">磁盘碎片</h3>
<p>指一个文件内容所在的block过于分散，导致磁盘磁头移动距离过大，从而降低磁盘读写性能。</p>
<h3 id="block">block</h3>
<p>在Ext2文件系统中所支持的block大小有1k，2k及4k三种，不同的大小限制了单个文件和文件系统的最大大小。</p>
<p>一个block只能被一个文件所使用，未使用的部分直接浪费了，因此需要存储大量的小文件，那么最好使用比较小的block</p>
<h3 id="inode">inode</h3>
<p>inode具体包含一下的信息</p>
<ul>
<li>权限（read/write/excute）</li>
<li>拥有者与群组</li>
<li>容量</li>
<li>建立或状态改变的事件</li>
<li>最近读取事件</li>
<li>最近修改事件</li>
<li>定义文件特性的旗标（flag），如SetUID</li>
<li>该文件真正内容的指向</li>
</ul>
<p>inode具有一下特点：</p>
<ul>
<li>每个inode大小固定未128bytes</li>
<li>每个文件仅占用一个inode</li>
</ul>
<p>一个inode大小无法直接引用多的block编号，引入了间接、双间接、三间接引用。间接引用让inode记录的引用block块记录引用信息</p>
<h3 id="目录">目录</h3>
<p>建立一个目录时，会分配一个inode与至少一个block。block记录的内容是目录下所有文件的inode编号以及文件名</p>
<p>文件的inode本身不记录文件名，文件名记录在目录中，因此新增文件、删除文件、更改文件名这些操作与目录的写权限有关。</p>
<h3 id="日志">日志</h3>
<p>如果突然断电，文件系统会发生错误，例如断电前只修复了block bitmap 还没有将数据真正写入block中</p>
<p>ext3/ext4 文件系统引入了日志功能，可以利用日志来修复文件系统</p>
<h3 id="挂载">挂载</h3>
<p>挂载利用目录作为文件系统的进入点，也就是说，进入目录之后就可以读取文件系统的数据.</p>
<h3 id="数据恢复的原理"><strong>数据恢复的原理</strong></h3>
<p>在ext3和ext4文件系统中,每个文件都是通过inode来描述其数据存放的具体位置,当文件被删除以后,inode的数据指针部分被清零,文件目录区没有太多的变化.文件的读写都是通过inode来实现的,当inode数据指针被清零以后,即使文件内容还在,也没有办法把文件内容组合出来.当ext3和ext4文件系统中元数据metadata发生变化时,相应的元数据在metadata在<strong>日志文件</strong>中会有一份拷贝.注意的时这个日志文件是循环使用的,当操作过多时,删除的文件的inode日志记录会被新的数据替换,这就彻底丧失了inode找回数据的机会了.</p>
<h2 id="文件">文件</h2>
<p>可以将一组权限用数字来表示,此时一组权限的3个位当作二进制数字的位,从左到右每个位的权值为4.2.1 即每个权限对应的数字权限为r:4  w:2 x:1</p>
<h3 id="默认权限">默认权限</h3>
<ul>
<li>文件默认权限:文件默认没有可执行权限,因此为666,也就是-rw-rw-rw</li>
<li>目录默认权限:目录必须要能够进入,也就是必须拥有可执行权限.因此未777</li>
</ul>
<p>可以通过umask设置或者查看默认权限,通常以掩码的形式表示,例如002表示其他用户的权限去除了一个2的权限</p>
<h3 id="目录的权限">目录的权限</h3>
<p>文件名不是存储在一个文件的内容,而是存储在一个文件所在的目录中.因此拥有文件的w权限不能对文件进行修改</p>
<p>目录存储文件列表,一个目录的权限也就是对其文件列表的权限.</p>
<hr>
<h3 id="链接">链接</h3>
<pre><code class="language-mermaid" data-lang="mermaid">graph LR

实体链接 --&gt; inode
block(文件) --&gt; inode
符号链接 --&gt; block







</code></pre><pre><code>ln 
-s:默认是实体链接,加-s为符号链接
-f:如果目标文件存在,先删除目标文件
</code></pre><h4 id="实体链接">实体链接</h4>
<p>在目录下创建一个条目,记录着文件名与inode编号,这个inode就是源文件的inode</p>
<p>删除任意一个条目,文件还是存在,只要引用数量不为0.</p>
<p>注意:不能跨越文件系统,不能对目录进行连接</p>
<h4 id="符号链接">符号链接</h4>
<p>符号链接文件保存着源文件所在的绝对路径,会在读取时定位到源文件上,可以理解为windows的快捷方式.</p>
<p>当源文件被删除了,链接文件就打不开了.</p>
<p>因为记录的是路径,所以可以 为目录建立符号链接.</p>
<h3 id="指令与文件搜索">指令与文件搜索</h3>
<p>which</p>
<p>whereis</p>
<p>locate</p>
<p>find</p>
<h2 id="进程管理">进程管理</h2>
<h3 id="查看进程">查看进程</h3>
<ul>
<li>
<p>ps   查看某个时间点的进程信息</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">ps -l    <span style="color:#75715e">#查看自己的进程</span>
ps aux   <span style="color:#75715e">#查看系统所有进程</span>
ps aux|grep threadx <span style="color:#75715e">#查看特定的进程</span>
</code></pre></div></li>
<li>
<p>pstree 查看进程树</p>
</li>
<li>
<p>top 实时显示进程信息</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">top -d <span style="color:#ae81ff">2</span> <span style="color:#75715e">#每两秒刷新一次</span>
</code></pre></div></li>
<li>
<p>netstat 查看占用端口的进程</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">netstat  -anp | grep port   <span style="color:#75715e">#查看占用特定端口的进程</span>
</code></pre></div></li>
</ul>
<h2 id="进程状态">进程状态</h2>
<table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>R</td>
<td>running or runnable (on run queue) 正在执行或者可执行，此时进程位于执行队列中。</td>
</tr>
<tr>
<td>D</td>
<td>uninterruptible sleep (usually I/O) 不可中断阻塞，通常为 IO 阻塞。</td>
</tr>
<tr>
<td>S</td>
<td>interruptible sleep (waiting for an event to complete) 可中断阻塞，此时进程正在等待某个事件完成。</td>
</tr>
<tr>
<td>Z</td>
<td>zombie (terminated but not reaped by its parent) 僵死，进程已经终止但是尚未被其父进程获取信息。</td>
</tr>
<tr>
<td>T</td>
<td>stopped (either by a job control signal or because it is being traced) 结束，进程既可以被作业控制信号结束，也可能是正在被追踪。</td>
</tr>
</tbody>
</table>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200624162319200.png" alt="image-20200624162319200"></p>
<h2 id="sigchld">SIGCHLD</h2>
<p>当一个子进程改变了它的状态时(停止运行,继续运行或者退出),有两件事会发生在父进程中:</p>
<ul>
<li>得到SIGCHLD信号</li>
<li>waitpid()或者wait()调用会返回</li>
</ul>
<p>其中子进程发送您的SIGCHLD信号包含了子进程的信息,比如进程ID,进程状态,进程使用的CPU的时间等.</p>
<p>在子进程退出时,它的进程描述符不会立刻释放,为了让父进程得到子进程信息,父进程通过wait()和waitpid()来获得一个已经退出的子进程的信息</p>
<h3 id="wait">wait()</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">pid_t wait(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>status)Copy to clipboardErrorCopied
</code></pre></div><p>父进程调用 wait() 会一直阻塞，直到收到一个子进程退出的 SIGCHLD 信号，之后 wait() 函数会销毁子进程并返回。</p>
<p>如果成功，返回被收集的子进程的进程 ID；如果调用进程没有子进程，调用就会失败，此时返回 -1，同时 errno 被置为 ECHILD。</p>
<p>参数 status 用来保存被收集的子进程退出时的一些状态，如果对这个子进程是如何死掉的毫不在意，只想把这个子进程消灭掉，可以设置这个参数为 NULL。</p>
<h3 id="waitpid">waitpid()</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">pid_t waitpid(pid_t pid, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>status, <span style="color:#66d9ef">int</span> options)Copy to clipboardErrorCopied
</code></pre></div><p>作用和 wait() 完全相同，但是多了两个可由用户控制的参数 pid 和 options。</p>
<p>pid 参数指示一个子进程的 ID，表示只关心这个子进程退出的 SIGCHLD 信号。如果 pid=-1 时，那么和 wait() 作用相同，都是关心所有子进程退出的 SIGCHLD 信号。</p>
<p>options 参数主要有 WNOHANG 和 WUNTRACED 两个选项，WNOHANG 可以使 waitpid() 调用变成非阻塞的，也就是说它会立即返回，父进程可以继续执行其它任务。</p>
<h2 id="孤儿进程">孤儿进程</h2>
<p>一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。</p>
<p>孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。</p>
<p>由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。</p>
<h2 id="僵尸进程">僵尸进程</h2>
<p>一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。</p>
<p>僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）。</p>
<p>系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。</p>
<p>要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 进程所收养，这样 init 进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。</p>

</div>


  </main>

  <footer>
  <div class="copyright">
    &copy; Antonio.D.C 2020 · <a href="https://creativecommons.org/licenses/by-sa/4.0">CC BY-SA 4.0</a>
  </div>
</footer>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/js/all.min.js"
          integrity="sha256-MAgcygDRahs+F/Nk5Vz387whB4kSK9NXlDN3w58LLq0="
          crossorigin="anonymous"></script>

  <script src="https://antoniodc-aaa.github.io/js/blog.js"></script>

  
</body>
</html>
