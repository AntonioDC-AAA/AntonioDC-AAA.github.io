<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="generator" content="Hugo 0.65.0-DEV" />

  <title>Effective Go &middot; Blog</title>

  <meta name="description" content="" />

  
  <meta property="og:locale" content="en-us"/>

  
  <meta property="og:image" content="https://antoniodc-aaa.github.io/images/name.jpg">

  
  <meta property="og:site_name" content="Blog"/>
  <meta property="og:title" content="Effective Go"/>
  <meta property="og:description" content="Effective Go 1.长命名并不会使其更具有可读性。一份有用的说明文档通常比额外的长命更有价值
2.Go并不对获取器（getter）和设置器（setter）提供自动支持。Get放在获取器的名字中，既不符合习惯，也不必要。如果有个名为ower的字段，获取器应为Ower（大写，可导出），而非GetOwer
若要提供设置器的方法，SetOwer是个不错的选择
3.和C一样，Go的正式语法使用分号来结束语句；和C不同的时，这些分号并不出现在源码中。取而代之，词法分析器会使用一条简单的规则来自动插入分号，因此源码中基本就不用分号了。
4.Go语言只有for swtich，if ，此外还有一个包含类型选择和多路复用通信复用器的新结构：select
5."/>
  <meta property="og:url" content="https://antoniodc-aaa.github.io/post/%E5%85%B6%E4%BB%96/go%E8%AF%AD%E8%A8%80/effective-go/"/>
  <meta property="og:type" content="article"/>
  <meta property="article:published_time" content="2019-12-28T16:07:30&#43;0800"/>
  <meta property="article:modified_time" content="2019-12-28T16:07:30&#43;0800"/>
  <meta property="article:author" content="Antonio.D.C">
  
  
  

  <script type="application/ld+json">
  {
    "@context" : "http://schema.org",
    "@type" : "Blog",
    "name": "Blog",
    "url" : "https://antoniodc-aaa.github.io/",
    "image": "https://antoniodc-aaa.github.io/images/name.jpg",
    "description": "You only live once !"
  }
  </script>

  
  <script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "name": "Effective Go",
    "headline": "Effective Go",
    "datePublished": "2019-12-28T16:07:30\x2b0800",
    "dateModified": "2019-12-28T16:07:30\x2b0800",
    "author": {
      "@type": "Person",
      "name": "Antonio.D.C",
      "url": "https://antoniodc-aaa.github.io/"
    },
    "image": "https://antoniodc-aaa.github.io/images/name.jpg",
    "url": "https://antoniodc-aaa.github.io/post/%E5%85%B6%E4%BB%96/go%E8%AF%AD%E8%A8%80/effective-go/",
    "description": "Effective Go 1.长命名并不会使其更具有可读性。一份有用的说明文档通常比额外的长命更有价值\n2.Go并不对获取器（getter）和设置器（setter）提供自动支持。Get放在获取器的名字中，既不符合习惯，也不必要。如果有个名为ower的字段，获取器应为Ower（大写，可导出），而非GetOwer\n若要提供设置器的方法，SetOwer是个不错的选择\n3.和C一样，Go的正式语法使用分号来结束语句；和C不同的时，这些分号并不出现在源码中。取而代之，词法分析器会使用一条简单的规则来自动插入分号，因此源码中基本就不用分号了。\n4.Go语言只有for swtich，if ，此外还有一个包含类型选择和多路复用通信复用器的新结构：select\n5."
  }
  </script>
  


  <link type="text/css"
        rel="stylesheet"
        href="https://antoniodc-aaa.github.io/css/print.css"
        media="print">

  <link type="text/css"
        rel="stylesheet"
        href="https://antoniodc-aaa.github.io/css/poole.css">

  <link type="text/css"
        rel="stylesheet"
        href="https://antoniodc-aaa.github.io/css/hyde.css">

  
<style type="text/css">
  .sidebar {
    background-color: #fc21803;
  }

  .read-more-link a {
    border-color: #fc21803;
  }

  footer a,
  .content a,
  .related-posts li a:hover {
    color: #fc21803;
  }
</style>



  <link type="text/css" rel="stylesheet" href="https://antoniodc-aaa.github.io/css/blog.css">

  <link rel="stylesheet"
        href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700&display=swap">

  <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css"
        integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk="
        crossorigin="anonymous" />

  <link rel="apple-touch-icon-precomposed"
        sizes="144x144"
        href="/apple-touch-icon-144-precomposed.png">

  <link rel="shortcut icon" href="/favicon.png">

  
  </head>
<body>
  <aside class="sidebar">
  <div class="container">
    <div class="sidebar-about">
      
        
        <div class="author-image">
          <img src="https://antoniodc-aaa.github.io/images/name.jpg" class="img-circle img-headshot center" alt="Profile Picture">
        </div>
        
      

      <h1>Blog</h1>

      
      <p class="lead">You only live once !</p>
      
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li>
          <a href="https://antoniodc-aaa.github.io/">Home</a>
        </li>
        <li>
          <a href="/post/"> Posts </a>
        </li><li>
          <a href="/tags/"> Tags </a>
        </li><li>
          <a href="/about/"> About </a>
        </li>
      </ul>
    </nav>

    <section class="social-icons">
      
      <a href="https://github.com/" rel="me" title="GitHub">
        <i class="fab fa-github" aria-hidden="true"></i>
      </a>
      
    </section>
  </div>
</aside>


  <main class="content container">
  <div class="post">
  <h1>Effective Go</h1>

  <div class="post-date">
    <time datetime="2019-12-28T16:07:30&#43;0800">Dec 28, 2019</time> · 2 min read
  </div>

  <h1 id="effective-go">Effective Go</h1>
<p>1.长命名并不会使其更具有可读性。一份有用的说明文档通常比额外的长命更有价值</p>
<p>2.Go并不对获取器（getter）和设置器（setter）提供自动支持。Get放在获取器的名字中，既不符合习惯，也不必要。如果有个名为ower的字段，获取器应为Ower（大写，可导出），而非GetOwer</p>
<p>若要提供设置器的方法，SetOwer是个不错的选择</p>
<p>3.和C一样，Go的正式语法使用分号来结束语句；和C不同的时，这些分号并不出现在源码中。取而代之，词法分析器会使用一条简单的规则来自动插入分号，因此源码中基本就不用分号了。</p>
<p><img src="C:%5CUsers%5CAntonio.DC%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200109105108126.png" alt="image-20200109105108126"></p>
<p><img src="C:%5CUsers%5CAntonio.DC%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200109105118497.png" alt="image-20200109105118497"></p>
<p>4.Go语言只有for swtich，if ，此外还有一个包含类型选择和多路复用通信复用器的新结构：select</p>
<p>5.</p>
<p><img src="C:%5CUsers%5CAntonio.DC%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200109105521041.png" alt="image-20200109105521041"></p>
<p>6.Go语言的形参和返回值在词法上处于大括号之外，但它们的作用域和该函数体仍然相同</p>
<p>7.<img src="C:%5CUsers%5CAntonio.DC%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200109111409356.png" alt="image-20200109111409356"></p>
<p><img src="C:%5CUsers%5CAntonio.DC%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200109111421049.png" alt="image-20200109111421049"></p>
<p>8.<img src="C:%5CUsers%5CAntonio.DC%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200109111607717.png" alt="image-20200109111607717"></p>
<p>当然continue也能接受一个可选的标签，不过它只能在循环中使用</p>
<p>9.switch t := t.(type){}可以用作类型断言</p>
<p>10.被推迟函数的实参（如果该函数为方法则还包括接收者）在推迟执行时会被求值，而不是在调用执行时才求值。这样不仅无需担心变量值在函数执行时被改变，同时还意味着单个被推迟的调用可推迟多个函数执行。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">trace</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">string</span> {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;entering:&#34;</span>, <span style="color:#a6e22e">s</span>)
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">s</span>
} 

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">un</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>) {
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;leaving:&#34;</span>, <span style="color:#a6e22e">s</span>)
}
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">a</span>() {
	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">un</span>(<span style="color:#a6e22e">trace</span>(<span style="color:#e6db74">&#34;a&#34;</span>))
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;in a&#34;</span>)
} 
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">b</span>() {
	<span style="color:#66d9ef">defer</span> <span style="color:#a6e22e">un</span>(<span style="color:#a6e22e">trace</span>(<span style="color:#e6db74">&#34;b&#34;</span>))
	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;in b&#34;</span>)
	<span style="color:#a6e22e">a</span>()
} 
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#a6e22e">b</span>()
}

<span style="color:#75715e">/*
</span><span style="color:#75715e">prints
</span><span style="color:#75715e">会打印
</span><span style="color:#75715e">entering: b
</span><span style="color:#75715e">in b
</span><span style="color:#75715e">entering: a
</span><span style="color:#75715e">in a
</span><span style="color:#75715e">leaving: a
</span><span style="color:#75715e">leaving: b
</span><span style="color:#75715e">*/</span>
</code></pre></div><p>11.new用来分配内存的内建函数，但与其他语言中的同名函数不同，它不会初始化内存，只会姜内存置零。new(T) 会为类型为 T 的新项分配已置零的内存空间， 并返回它的地址， 也就是一个
类型为 *T 的值。 用 Go 的术语来说， 它返回一个指针， 该指针指向新分配的， 类型为 T 的零值。</p>
<p>请注意， 返回一个局部变量的地址完全没有问题， 这点与 C 不同。 该局部变量对应的数据 在函数返回后依然有效。 实际上， 每当获取一个复合字面量的地址时， 都将为一个新的实例分配内存， 因此我们可以将上面的最后两行代码合并：
return &amp;File{fd, name, nil, 0}</p>
<p>12.</p>
<p>再回到内存分配上来。 内建函数 make(T, args) 的目的不同于 new(T)。 它只用于创建切片、映射和信道， 并返回类型为 T（ 而非 *T ） 的一个已初始化 （ 而非置零） 的值。 出现这种用差异的原因在于， 这三种类型本质上为引用数据类型， 它们在使用前必须初始化。  make 用于初始化其内部的数据结构并准备好将要使用的值  。</p>
<p>请记住， make 只适用于映射、 切片和信道且不返回指针。 若要获得明确的指针， 请使用
new 分配内存或显式地获取一个变量的地址。</p>
<p>13.</p>
<p>有时必须分配一个二维数组， 例如在处理像素的扫描行时， 这种情况就会发生。 我们有两种
方式来达到这个目的。 一种就是独立地分配每一个切片； 而另一种就是只分配一个数组， 将
各个切片都指向它。 采用哪种方式取决于你的应用。 若切片会增长或收缩， 就应该通过独立
分配来避免覆盖下一行； 若不会， 用单次分配来构造对象会更加高效。 以下是这两种方法的
大概代码， 仅供参考。 首先是一次一行的：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 分配顶层切片。
</span><span style="color:#75715e"></span><span style="color:#a6e22e">picture</span> <span style="color:#f92672">:=</span> make([][]<span style="color:#66d9ef">uint8</span>, <span style="color:#a6e22e">YSize</span>) <span style="color:#75715e">// 每 y 个单元一行。
</span><span style="color:#75715e"></span><span style="color:#75715e">// 遍历行， 为每一行都分配切片
</span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">picture</span> {
	<span style="color:#a6e22e">picture</span>[<span style="color:#a6e22e">i</span>] = make([]<span style="color:#66d9ef">uint8</span>, <span style="color:#a6e22e">XSize</span>)
}


</code></pre></div><p>现在是一次分配， 对行进行切片：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// 分配顶层切片， 和前面一样。
</span><span style="color:#75715e"></span><span style="color:#a6e22e">picture</span> <span style="color:#f92672">:=</span> make([][]<span style="color:#66d9ef">uint8</span>, <span style="color:#a6e22e">YSize</span>) <span style="color:#75715e">// 每 y 个单元一行。
</span><span style="color:#75715e"></span><span style="color:#75715e">// 分配一个大的切片来保存所有像素
</span><span style="color:#75715e"></span><span style="color:#a6e22e">pixels</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">uint8</span>, <span style="color:#a6e22e">XSize</span><span style="color:#f92672">*</span><span style="color:#a6e22e">YSize</span>) <span style="color:#75715e">// 拥有类型 []uint8， 尽管图片是 [][]uint8.
</span><span style="color:#75715e"></span><span style="color:#75715e">// 遍历行， 从剩余像素切片的前面切出每行来。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">picture</span> {
<span style="color:#a6e22e">picture</span>[<span style="color:#a6e22e">i</span>], <span style="color:#a6e22e">pixels</span> = <span style="color:#a6e22e">pixels</span>[:<span style="color:#a6e22e">XSize</span>], <span style="color:#a6e22e">pixels</span>[<span style="color:#a6e22e">XSize</span>:]
}
</code></pre></div><p>当遇到 string 或 []byte 值时， 可使用 %q 产生带引号的字符串； 而
格式 %#q 会尽可能使用反引号。</p>

</div>


  </main>

  <footer>
  <div class="copyright">
    &copy; Antonio.D.C 2020 · <a href="https://creativecommons.org/licenses/by-sa/4.0">CC BY-SA 4.0</a>
  </div>
</footer>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/js/all.min.js"
          integrity="sha256-MAgcygDRahs+F/Nk5Vz387whB4kSK9NXlDN3w58LLq0="
          crossorigin="anonymous"></script>

  <script src="https://antoniodc-aaa.github.io/js/blog.js"></script>

  
</body>
</html>
