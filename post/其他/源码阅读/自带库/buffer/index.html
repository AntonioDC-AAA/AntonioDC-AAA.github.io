<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="generator" content="Hugo 0.65.0-DEV" />

  <title>Buffer包 &middot; Blog</title>

  <meta name="description" content="" />

  
  <meta property="og:locale" content="en-us"/>

  
  <meta property="og:image" content="https://antoniodc-aaa.github.io/images/name.jpg">

  
  <meta property="og:site_name" content="Blog"/>
  <meta property="og:title" content="Buffer包"/>
  <meta property="og:description" content="bytes包中的buffer Buffer是一个实现了读写方法的可变大小的字节缓冲。本类型的零值是一个空的可用于读写的缓冲。
1.初始化的最小内存是64字节
// smallBufferSize is an initial allocation minimal capacity."/>
  <meta property="og:url" content="https://antoniodc-aaa.github.io/post/%E5%85%B6%E4%BB%96/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/%E8%87%AA%E5%B8%A6%E5%BA%93/buffer/"/>
  <meta property="og:type" content="article"/>
  <meta property="article:published_time" content="0001-01-01T00:00:00Z"/>
  <meta property="article:modified_time" content="0001-01-01T00:00:00Z"/>
  <meta property="article:author" content="Antonio.D.C">
  
  
  

  <script type="application/ld+json">
  {
    "@context" : "http://schema.org",
    "@type" : "Blog",
    "name": "Blog",
    "url" : "https://antoniodc-aaa.github.io/",
    "image": "https://antoniodc-aaa.github.io/images/name.jpg",
    "description": "You only live once !"
  }
  </script>

  
  <script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "name": "Buffer包",
    "headline": "Buffer包",
    "datePublished": "0001-01-01T00:00:00Z",
    "dateModified": "0001-01-01T00:00:00Z",
    "author": {
      "@type": "Person",
      "name": "Antonio.D.C",
      "url": "https://antoniodc-aaa.github.io/"
    },
    "image": "https://antoniodc-aaa.github.io/images/name.jpg",
    "url": "https://antoniodc-aaa.github.io/post/%E5%85%B6%E4%BB%96/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/%E8%87%AA%E5%B8%A6%E5%BA%93/buffer/",
    "description": "bytes包中的buffer Buffer是一个实现了读写方法的可变大小的字节缓冲。本类型的零值是一个空的可用于读写的缓冲。\n1.初始化的最小内存是64字节\n\/\/ smallBufferSize is an initial allocation minimal capacity."
  }
  </script>
  


  <link type="text/css"
        rel="stylesheet"
        href="https://antoniodc-aaa.github.io/css/print.css"
        media="print">

  <link type="text/css"
        rel="stylesheet"
        href="https://antoniodc-aaa.github.io/css/poole.css">

  <link type="text/css"
        rel="stylesheet"
        href="https://antoniodc-aaa.github.io/css/hyde.css">

  
<style type="text/css">
  .sidebar {
    background-color: #fc21803;
  }

  .read-more-link a {
    border-color: #fc21803;
  }

  footer a,
  .content a,
  .related-posts li a:hover {
    color: #fc21803;
  }
</style>



  <link type="text/css" rel="stylesheet" href="https://antoniodc-aaa.github.io/css/blog.css">

  <link rel="stylesheet"
        href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700&display=swap">

  <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css"
        integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk="
        crossorigin="anonymous" />

  <link rel="apple-touch-icon-precomposed"
        sizes="144x144"
        href="/apple-touch-icon-144-precomposed.png">

  <link rel="shortcut icon" href="/favicon.png">

  
  </head>
<body>
  <aside class="sidebar">
  <div class="container">
    <div class="sidebar-about">
      
        
        <div class="author-image">
          <img src="https://antoniodc-aaa.github.io/images/name.jpg" class="img-circle img-headshot center" alt="Profile Picture">
        </div>
        
      

      <h1>Blog</h1>

      
      <p class="lead">You only live once !</p>
      
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li>
          <a href="https://antoniodc-aaa.github.io/">Home</a>
        </li>
        <li>
          <a href="/post/"> Posts </a>
        </li><li>
          <a href="/tags/"> Tags </a>
        </li><li>
          <a href="/about/"> About </a>
        </li>
      </ul>
    </nav>

    <section class="social-icons">
      
      <a href="https://github.com/" rel="me" title="GitHub">
        <i class="fab fa-github" aria-hidden="true"></i>
      </a>
      
      <a href="#" rel="me" title="Twitter">
        <i class="fab fa-twitter" aria-hidden="true"></i>
      </a>
      
    </section>
  </div>
</aside>


  <main class="content container">
  <div class="post">
  <h1>Buffer包</h1>

  <div class="post-date">
    <time datetime="0001-01-01T00:00:00Z">Jan 1, 0001</time> · 8 min read
  </div>

  <h1 id="bytes包中的buffer">bytes包中的buffer</h1>
<p>Buffer是一个实现了读写方法的可变大小的字节缓冲。本类型的零值是一个空的可用于读写的缓冲。</p>
<p>1.初始化的最小内存是64字节</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// smallBufferSize is an initial allocation minimal capacity.const smallBufferSize = 64
</span></code></pre></div><p>2.结构体是</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Buffer</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#a6e22e">buf</span>      []<span style="color:#66d9ef">byte</span> <span style="color:#75715e">// contents are the bytes buf[off : len(buf)]   
</span><span style="color:#75715e"></span>    
    <span style="color:#a6e22e">off</span>      <span style="color:#66d9ef">int</span>    <span style="color:#75715e">// read at &amp;buf[off], write at &amp;buf[len(buf)]  
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">lastRead</span> <span style="color:#a6e22e">readOp</span> <span style="color:#75715e">// last read operation, so that Unread* can work correctly.
</span><span style="color:#75715e"></span>}
</code></pre></div><p>3.操作类型</p>
<pre><code>type readOp int8
const (
	opRead      readOp = -1 // Any other read operation.
	opInvalid   readOp = 0  // Non-read operation.
	opReadRune1 readOp = 1  // Read rune of size 1.
	opReadRune2 readOp = 2  // Read rune of size 2.
	opReadRune3 readOp = 3  // Read rune of size 3.
	opReadRune4 readOp = 4  // Read rune of size 4.
)

</code></pre><h2 id="自动增长">自动增长</h2>
<p>4.既然是自动增长的，那么底层是如何实现自动增长的呢？</p>
<p>4-1 此函数是根据切片的数据结构实现的，切片的len与cap</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// tryGrowByReslice is a inlineable version of grow for the fast-case where the
</span><span style="color:#75715e"></span><span style="color:#75715e">// internal buffer only needs to be resliced.
</span><span style="color:#75715e"></span><span style="color:#75715e">// It returns the index where bytes should be written and whether it succeeded.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Buffer</span>) <span style="color:#a6e22e">tryGrowByReslice</span>(<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>) (<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">bool</span>) {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">l</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">buf</span>); <span style="color:#a6e22e">n</span> <span style="color:#f92672">&lt;=</span> cap(<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">buf</span>)<span style="color:#f92672">-</span><span style="color:#a6e22e">l</span> {
		<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">buf</span> = <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">buf</span>[:<span style="color:#a6e22e">l</span><span style="color:#f92672">+</span><span style="color:#a6e22e">n</span>]
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">l</span>, <span style="color:#66d9ef">true</span>
	}
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">false</span>
}

</code></pre></div><p>4-2 以2*cap+n的方式增长</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// grow grows the buffer to guarantee space for n more bytes.
</span><span style="color:#75715e"></span><span style="color:#75715e">// It returns the index where bytes should be written.
</span><span style="color:#75715e"></span><span style="color:#75715e">// If the buffer can&#39;t grow it will panic with ErrTooLarge.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Buffer</span>) <span style="color:#a6e22e">grow</span>(<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">int</span> {
    <span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">Len</span>()												<span style="color:#75715e">//cad::len(buf)-off
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// If buffer is empty, reset to recover space.
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">m</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">off</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {						
		<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">Reset</span>()
	}
	<span style="color:#75715e">// Try to grow by means of a reslice.
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">tryGrowByReslice</span>(<span style="color:#a6e22e">n</span>); <span style="color:#a6e22e">ok</span> {
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">i</span>
	}
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">buf</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">smallBufferSize</span> {		<span style="color:#75715e">//空切片的时候，申请的内存少于size的时候申请最小单位的内存
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">buf</span> = make([]<span style="color:#66d9ef">byte</span>, <span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">smallBufferSize</span>)
		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
	}
	<span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> cap(<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">buf</span>)
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">c</span><span style="color:#f92672">/</span><span style="color:#ae81ff">2</span><span style="color:#f92672">-</span><span style="color:#a6e22e">m</span> {                             							<span style="color:#75715e">//你可以将原有的增加，而不是分配一个新的
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// We can slide things down instead of allocating a new	  
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// slice. We only need m+n &lt;= c to slide, but
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// we instead let capacity get twice as large so we
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// don&#39;t spend all our time copying.
</span><span style="color:#75715e"></span>		copy(<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">buf</span>, <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">buf</span>[<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">off</span>:])
	} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">c</span> &gt; <span style="color:#a6e22e">maxInt</span><span style="color:#f92672">-</span><span style="color:#a6e22e">c</span><span style="color:#f92672">-</span><span style="color:#a6e22e">n</span> {
		panic(<span style="color:#a6e22e">ErrTooLarge</span>)
	} <span style="color:#66d9ef">else</span> {
        <span style="color:#75715e">//每次都申请2c+n
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// Not enough space anywhere, we need to allocate.
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">buf</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">makeSlice</span>(<span style="color:#ae81ff">2</span><span style="color:#f92672">*</span><span style="color:#a6e22e">c</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">n</span>)			  <span style="color:#75715e">//带有异常延时的创建切片
</span><span style="color:#75715e"></span>		copy(<span style="color:#a6e22e">buf</span>, <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">buf</span>[<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">off</span>:])				
		<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">buf</span> = <span style="color:#a6e22e">buf</span>
	}
	<span style="color:#75715e">// Restore b.off and len(b.buf).
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">off</span> = <span style="color:#ae81ff">0</span>
	<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">buf</span> = <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">buf</span>[:<span style="color:#a6e22e">m</span><span style="color:#f92672">+</span><span style="color:#a6e22e">n</span>]
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">m</span>
}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// Grow grows the buffer&#39;s capacity, if necessary, to guarantee space for
</span><span style="color:#75715e"></span><span style="color:#75715e">// another n bytes. After Grow(n), at least n bytes can be written to the
</span><span style="color:#75715e"></span><span style="color:#75715e">// buffer without another allocation.
</span><span style="color:#75715e"></span><span style="color:#75715e">// If n is negative, Grow will panic.
</span><span style="color:#75715e"></span><span style="color:#75715e">// If the buffer can&#39;t grow it will panic with ErrTooLarge.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Buffer</span>) <span style="color:#a6e22e">Grow</span>(<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>) {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">n</span> &lt; <span style="color:#ae81ff">0</span> {
		panic(<span style="color:#e6db74">&#34;bytes.Buffer.Grow: negative count&#34;</span>)
	}
	<span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">grow</span>(<span style="color:#a6e22e">n</span>)
	<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">buf</span> = <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">buf</span>[:<span style="color:#a6e22e">m</span>]
}
</code></pre></div><h2 id="写">写</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// Write appends the contents of p to the buffer, growing the buffer as
</span><span style="color:#75715e"></span><span style="color:#75715e">// needed. The return value n is the length of p; err is always nil. If the
</span><span style="color:#75715e"></span><span style="color:#75715e">// buffer becomes too large, Write will panic with ErrTooLarge.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Buffer</span>) <span style="color:#a6e22e">Write</span>(<span style="color:#a6e22e">p</span> []<span style="color:#66d9ef">byte</span>) (<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>) {
	<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">lastRead</span> = <span style="color:#a6e22e">opInvalid</span>			   										 <span style="color:#75715e">//开始将标志位设置为数据无效
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">m</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">tryGrowByReslice</span>(len(<span style="color:#a6e22e">p</span>))						  <span style="color:#75715e">//分配切片内存
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">ok</span> {
		<span style="color:#a6e22e">m</span> = <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">grow</span>(len(<span style="color:#a6e22e">p</span>))													   <span style="color:#75715e">//增长内存
</span><span style="color:#75715e"></span>	}
	<span style="color:#66d9ef">return</span> copy(<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">buf</span>[<span style="color:#a6e22e">m</span>:], <span style="color:#a6e22e">p</span>), <span style="color:#66d9ef">nil</span>
}

<span style="color:#75715e">// WriteString appends the contents of s to the buffer, growing the buffer as
</span><span style="color:#75715e"></span><span style="color:#75715e">// needed. The return value n is the length of s; err is always nil. If the
</span><span style="color:#75715e"></span><span style="color:#75715e">// buffer becomes too large, WriteString will panic with ErrTooLarge.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Buffer</span>) <span style="color:#a6e22e">WriteString</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>) (<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>) {
	<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">lastRead</span> = <span style="color:#a6e22e">opInvalid</span>
	<span style="color:#a6e22e">m</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">tryGrowByReslice</span>(len(<span style="color:#a6e22e">s</span>))
	<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">ok</span> {
		<span style="color:#a6e22e">m</span> = <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">grow</span>(len(<span style="color:#a6e22e">s</span>))
	}
	<span style="color:#66d9ef">return</span> copy(<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">buf</span>[<span style="color:#a6e22e">m</span>:], <span style="color:#a6e22e">s</span>), <span style="color:#66d9ef">nil</span>
}


<span style="color:#75715e">// WriteTo writes data to w until the buffer is drained or an error occurs.
</span><span style="color:#75715e"></span><span style="color:#75715e">// The return value n is the number of bytes written; it always fits into an
</span><span style="color:#75715e"></span><span style="color:#75715e">// int, but it is int64 to match the io.WriterTo interface. Any error
</span><span style="color:#75715e"></span><span style="color:#75715e">// encountered during the write is also returned.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Buffer</span>) <span style="color:#a6e22e">WriteTo</span>(<span style="color:#a6e22e">w</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Writer</span>) (<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int64</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>) {
	<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">lastRead</span> = <span style="color:#a6e22e">opInvalid</span>            					<span style="color:#75715e">//数据无效状态
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">nBytes</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">Len</span>(); <span style="color:#a6e22e">nBytes</span> &gt; <span style="color:#ae81ff">0</span> {				<span style="color:#75715e">//len - off
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">m</span>, <span style="color:#a6e22e">e</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">w</span>.<span style="color:#a6e22e">Write</span>(<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">buf</span>[<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">off</span>:])				<span style="color:#75715e">//写入buf中
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">m</span> &gt; <span style="color:#a6e22e">nBytes</span> {											<span style="color:#75715e">//如果写入的字节超过剩余容量
</span><span style="color:#75715e"></span>			panic(<span style="color:#e6db74">&#34;bytes.Buffer.WriteTo: invalid Write count&#34;</span>)
		}
		<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">off</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">m</span>												<span style="color:#75715e">// 偏移值增加
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">n</span> = int64(<span style="color:#a6e22e">m</span>)											<span style="color:#75715e">//写入的是m个字节的长度
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">e</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">e</span>
		}
		<span style="color:#75715e">// all bytes should have been written, by definition of
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// Write method in io.Writer
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">m</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">nBytes</span> {										<span style="color:#75715e">//如果写入的字节不等于剩余容量
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">ErrShortWrite</span>
		}
	}
	<span style="color:#75715e">// Buffer is now empty; reset.
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">Reset</span>()
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">n</span>, <span style="color:#66d9ef">nil</span>
}



<span style="color:#75715e">// WriteByte appends the byte c to the buffer, growing the buffer as needed.
</span><span style="color:#75715e"></span><span style="color:#75715e">// The returned error is always nil, but is included to match bufio.Writer&#39;s
</span><span style="color:#75715e"></span><span style="color:#75715e">// WriteByte. If the buffer becomes too large, WriteByte will panic with
</span><span style="color:#75715e"></span><span style="color:#75715e">// ErrTooLarge.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Buffer</span>) <span style="color:#a6e22e">WriteByte</span>(<span style="color:#a6e22e">c</span> <span style="color:#66d9ef">byte</span>) <span style="color:#66d9ef">error</span> {
	<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">lastRead</span> = <span style="color:#a6e22e">opInvalid</span>           <span style="color:#75715e">//数据无效状态
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">m</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">tryGrowByReslice</span>(<span style="color:#ae81ff">1</span>)
	<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">ok</span> {								
		<span style="color:#a6e22e">m</span> = <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">grow</span>(<span style="color:#ae81ff">1</span>)
	}
	<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">buf</span>[<span style="color:#a6e22e">m</span>] = <span style="color:#a6e22e">c</span>
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
}
</code></pre></div><h2 id="读">读</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// MinRead is the minimum slice size passed to a Read call by
</span><span style="color:#75715e"></span><span style="color:#75715e">// Buffer.ReadFrom. As long as the Buffer has at least MinRead bytes beyond
</span><span style="color:#75715e"></span><span style="color:#75715e">// what is required to hold the contents of r, ReadFrom will not grow the
</span><span style="color:#75715e"></span><span style="color:#75715e">// underlying buffer.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">MinRead</span> = <span style="color:#ae81ff">512</span>


<span style="color:#75715e">// ReadFrom reads data from r until EOF and appends it to the buffer, growing
</span><span style="color:#75715e"></span><span style="color:#75715e">// the buffer as needed. The return value n is the number of bytes read. Any
</span><span style="color:#75715e"></span><span style="color:#75715e">// error except io.EOF encountered during the read is also returned. If the
</span><span style="color:#75715e"></span><span style="color:#75715e">// buffer becomes too large, ReadFrom will panic with ErrTooLarge.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Buffer</span>) <span style="color:#a6e22e">ReadFrom</span>(<span style="color:#a6e22e">r</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Reader</span>) (<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int64</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>) {		<span style="color:#75715e">//??????????
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">lastRead</span> = <span style="color:#a6e22e">opInvalid</span>
	<span style="color:#66d9ef">for</span> {
		<span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">grow</span>(<span style="color:#a6e22e">MinRead</span>)
		<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">buf</span> = <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">buf</span>[:<span style="color:#a6e22e">i</span>]
		<span style="color:#a6e22e">m</span>, <span style="color:#a6e22e">e</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">Read</span>(<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">buf</span>[<span style="color:#a6e22e">i</span>:cap(<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">buf</span>)])
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">m</span> &lt; <span style="color:#ae81ff">0</span> {
			panic(<span style="color:#a6e22e">errNegativeRead</span>)
		}

		<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">buf</span> = <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">buf</span>[:<span style="color:#a6e22e">i</span><span style="color:#f92672">+</span><span style="color:#a6e22e">m</span>]
		<span style="color:#a6e22e">n</span> <span style="color:#f92672">+=</span> int64(<span style="color:#a6e22e">m</span>)
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">e</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">EOF</span> {
			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">n</span>, <span style="color:#66d9ef">nil</span> <span style="color:#75715e">// e is EOF, so return nil explicitly
</span><span style="color:#75715e"></span>		}
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">e</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">e</span>
		}
	}
}

<span style="color:#75715e">// Next returns a slice containing the next n bytes from the buffer,
</span><span style="color:#75715e"></span><span style="color:#75715e">// advancing the buffer as if the bytes had been returned by Read.
</span><span style="color:#75715e"></span><span style="color:#75715e">// If there are fewer than n bytes in the buffer, Next returns the entire buffer.
</span><span style="color:#75715e"></span><span style="color:#75715e">// The slice is only valid until the next call to a read or write method.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Buffer</span>) <span style="color:#a6e22e">Next</span>(<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>) []<span style="color:#66d9ef">byte</span> {
	<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">lastRead</span> = <span style="color:#a6e22e">opInvalid</span>
	<span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">Len</span>()
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">n</span> &gt; <span style="color:#a6e22e">m</span> {
		<span style="color:#a6e22e">n</span> = <span style="color:#a6e22e">m</span>
	}
	<span style="color:#a6e22e">data</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">buf</span>[<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">off</span> : <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">off</span><span style="color:#f92672">+</span><span style="color:#a6e22e">n</span>]
	<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">off</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">n</span>
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">n</span> &gt; <span style="color:#ae81ff">0</span> {
		<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">lastRead</span> = <span style="color:#a6e22e">opRead</span>
	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">data</span>
}


<span style="color:#75715e">// Read reads the next len(p) bytes from the buffer or until the buffer
</span><span style="color:#75715e"></span><span style="color:#75715e">// is drained. The return value n is the number of bytes read. If the
</span><span style="color:#75715e"></span><span style="color:#75715e">// buffer has no data to return, err is io.EOF (unless len(p) is zero);
</span><span style="color:#75715e"></span><span style="color:#75715e">// otherwise it is nil.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Buffer</span>) <span style="color:#a6e22e">Read</span>(<span style="color:#a6e22e">p</span> []<span style="color:#66d9ef">byte</span>) (<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>) {
	<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">lastRead</span> = <span style="color:#a6e22e">opInvalid</span>					<span style="color:#75715e">//状态为数据无效
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">empty</span>() {										<span style="color:#75715e">//如为空
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// Buffer is empty, reset to recover space.
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">Reset</span>()
		<span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">p</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
			<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">nil</span>
		}
		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">EOF</span>
	}
	<span style="color:#a6e22e">n</span> = copy(<span style="color:#a6e22e">p</span>, <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">buf</span>[<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">off</span>:])   <span style="color:#75715e">//设置buf
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">off</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">n</span>									<span style="color:#75715e">//索引增加
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">n</span> &gt; <span style="color:#ae81ff">0</span> {
		<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">lastRead</span> = <span style="color:#a6e22e">opRead</span>		<span style="color:#75715e">//如果增加，最后的状态设置为读
</span><span style="color:#75715e"></span>	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">n</span>, <span style="color:#66d9ef">nil</span>
}



<span style="color:#75715e">// ReadByte reads and returns the next byte from the buffer.
</span><span style="color:#75715e"></span><span style="color:#75715e">// If no byte is available, it returns error io.EOF.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Buffer</span>) <span style="color:#a6e22e">ReadByte</span>() (<span style="color:#66d9ef">byte</span>, <span style="color:#66d9ef">error</span>) {
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">empty</span>() {							<span style="color:#75715e">//如果buf为空
</span><span style="color:#75715e"></span>		<span style="color:#75715e">// Buffer is empty, reset to recover space.
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">Reset</span>()
		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">EOF</span>
	}
	<span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">buf</span>[<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">off</span>]					<span style="color:#75715e">//buf读一个字节
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">off</span><span style="color:#f92672">++</span>									  <span style="color:#75715e">//下标增加
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">lastRead</span> = <span style="color:#a6e22e">opRead</span>
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">c</span>, <span style="color:#66d9ef">nil</span>
}


<span style="color:#75715e">// readSlice is like ReadBytes but returns a reference to internal buffer data.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Buffer</span>) <span style="color:#a6e22e">readSlice</span>(<span style="color:#a6e22e">delim</span> <span style="color:#66d9ef">byte</span>) (<span style="color:#a6e22e">line</span> []<span style="color:#66d9ef">byte</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>) {
	<span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">IndexByte</span>(<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">buf</span>[<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">off</span>:], <span style="color:#a6e22e">delim</span>)
	<span style="color:#a6e22e">end</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">off</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>					<span style="color:#75715e">//分隔符位置+1+当前位置
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">0</span> {
		<span style="color:#a6e22e">end</span> = len(<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">buf</span>)
		<span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">EOF</span>
	}
	<span style="color:#a6e22e">line</span> = <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">buf</span>[<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">off</span>:<span style="color:#a6e22e">end</span>]		<span style="color:#75715e">//读取的切片为off-end
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">off</span> = <span style="color:#a6e22e">end</span>								<span style="color:#75715e">//将索引设置为结尾位置
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">lastRead</span> = <span style="color:#a6e22e">opRead</span>
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">line</span>, <span style="color:#a6e22e">err</span>
}

<span style="color:#75715e">// ReadString reads until the first occurrence of delim in the input,
</span><span style="color:#75715e"></span><span style="color:#75715e">// returning a string containing the data up to and including the delimiter.
</span><span style="color:#75715e"></span><span style="color:#75715e">// If ReadString encounters an error before finding a delimiter,
</span><span style="color:#75715e"></span><span style="color:#75715e">// it returns the data read before the error and the error itself (often io.EOF).
</span><span style="color:#75715e"></span><span style="color:#75715e">// ReadString returns err != nil if and only if the returned data does not end
</span><span style="color:#75715e"></span><span style="color:#75715e">// in delim.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Buffer</span>) <span style="color:#a6e22e">ReadString</span>(<span style="color:#a6e22e">delim</span> <span style="color:#66d9ef">byte</span>) (<span style="color:#a6e22e">line</span> <span style="color:#66d9ef">string</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>) {
	<span style="color:#a6e22e">slice</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">readSlice</span>(<span style="color:#a6e22e">delim</span>)
	<span style="color:#66d9ef">return</span> string(<span style="color:#a6e22e">slice</span>), <span style="color:#a6e22e">err</span>
}
</code></pre></div><h2 id="已读">已读</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">// ReadFrom reads data from r until EOF and appends it to the buffer, growing
</span><span style="color:#75715e"></span><span style="color:#75715e">// the buffer as needed. The return value n is the number of bytes read. Any
</span><span style="color:#75715e"></span><span style="color:#75715e">// error except io.EOF encountered during the read is also returned. If the
</span><span style="color:#75715e"></span><span style="color:#75715e">// buffer becomes too large, ReadFrom will panic with ErrTooLarge.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Buffer</span>) <span style="color:#a6e22e">ReadFrom</span>(<span style="color:#a6e22e">r</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Reader</span>) (<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int64</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>) {		<span style="color:#75715e">//??????????
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">lastRead</span> = <span style="color:#a6e22e">opInvalid</span>
	<span style="color:#66d9ef">for</span> {
		<span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">grow</span>(<span style="color:#a6e22e">MinRead</span>)					<span style="color:#75715e">//申请内存
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">buf</span> = <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">buf</span>[:<span style="color:#a6e22e">i</span>]						
        <span style="color:#a6e22e">m</span>, <span style="color:#a6e22e">e</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">Read</span>(<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">buf</span>[<span style="color:#a6e22e">i</span>:cap(<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">buf</span>)])			<span style="color:#75715e">//读取的数据存放在i:cap中
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">m</span> &lt; <span style="color:#ae81ff">0</span> {										
			panic(<span style="color:#a6e22e">errNegativeRead</span>)
		}

		<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">buf</span> = <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">buf</span>[:<span style="color:#a6e22e">i</span><span style="color:#f92672">+</span><span style="color:#a6e22e">m</span>]					    <span style="color:#75715e">//buf赋值
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">n</span> <span style="color:#f92672">+=</span> int64(<span style="color:#a6e22e">m</span>)								<span style="color:#75715e">//n的数量需要增加m的数量
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">e</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">EOF</span> {							<span style="color:#75715e">//直到遇到结尾或者其他错误，返回
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">n</span>, <span style="color:#66d9ef">nil</span> <span style="color:#75715e">// e is EOF, so return nil explicitly
</span><span style="color:#75715e"></span>		}
		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">e</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
			<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">e</span>
		}
	}
}

<span style="color:#75715e">// Next returns a slice containing the next n bytes from the buffer,
</span><span style="color:#75715e"></span><span style="color:#75715e">// advancing the buffer as if the bytes had been returned by Read.
</span><span style="color:#75715e"></span><span style="color:#75715e">// If there are fewer than n bytes in the buffer, Next returns the entire buffer.
</span><span style="color:#75715e"></span><span style="color:#75715e">// The slice is only valid until the next call to a read or write method.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Buffer</span>) <span style="color:#a6e22e">Next</span>(<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>) []<span style="color:#66d9ef">byte</span> {
	<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">lastRead</span> = <span style="color:#a6e22e">opInvalid</span>
	<span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">Len</span>()								<span style="color:#75715e">//len - off
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">n</span> &gt; <span style="color:#a6e22e">m</span> {										<span style="color:#75715e">//如果要读入的字节大于剩余的字节，n = m
</span><span style="color:#75715e"></span>		<span style="color:#a6e22e">n</span> = <span style="color:#a6e22e">m</span>
	}
	<span style="color:#a6e22e">data</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">buf</span>[<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">off</span> : <span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">off</span><span style="color:#f92672">+</span><span style="color:#a6e22e">n</span>]		
	<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">off</span> <span style="color:#f92672">+=</span> <span style="color:#a6e22e">n</span>
	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">n</span> &gt; <span style="color:#ae81ff">0</span> {
		<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">lastRead</span> = <span style="color:#a6e22e">opRead</span>					<span style="color:#75715e">//设置状态为opRead状态
</span><span style="color:#75715e"></span>	}
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">data</span>
}


</code></pre></div>
</div>


  </main>

  <footer>
  <div class="copyright">
    &copy; Antonio.D.C 2020 · <a href="https://creativecommons.org/licenses/by-sa/4.0">CC BY-SA 4.0</a>
  </div>
</footer>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/js/all.min.js"
          integrity="sha256-MAgcygDRahs+F/Nk5Vz387whB4kSK9NXlDN3w58LLq0="
          crossorigin="anonymous"></script>

  <script src="https://antoniodc-aaa.github.io/js/blog.js"></script>

  
</body>
</html>
