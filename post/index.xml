<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Blog</title>
    <link>https://antoniodc-aaa.github.io/post/</link>
    <description>Recent content in Posts on Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 11 Jun 2020 10:27:22 +0800</lastBuildDate>
    
	<atom:link href="https://antoniodc-aaa.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Http与Https区别</title>
      <link>https://antoniodc-aaa.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/httpandhttps/</link>
      <pubDate>Thu, 11 Jun 2020 10:27:22 +0800</pubDate>
      
      <guid>https://antoniodc-aaa.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/httpandhttps/</guid>
      <description>HTTP&amp;amp;HTTPS简介 HTTP（超文本传送协议）是一种用于分布式、协作式和超媒体信息的应用层协议。HTTP是万维网的数据通信的基础。
HTTP有以下安全性问题：
 使用明文进行通信，内容可能会被窃听； 不验证通信方的身份，通信方的身份有可能遭遇伪装； 无法证明报文的完整性，报文有可能遭到篡改。  HTTPS并不是新协议，而是让HTTP和SSL（secure sockets layer）通信，再由SSL和TCP通信，也就是说HTTPS使用了隧道进行通信</description>
    </item>
    
    <item>
      <title>数据库锁机制</title>
      <link>https://antoniodc-aaa.github.io/post/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%94%81/</link>
      <pubDate>Sun, 19 Apr 2020 08:08:30 +0800</pubDate>
      
      <guid>https://antoniodc-aaa.github.io/post/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%94%81/</guid>
      <description>数据库锁机制 锁的种类 1.共享锁 ：共享锁不组织其他session同时读资源，但阻塞其他session update
2.更新锁： 我现在只想读，你们别人也可以读，但是我将来可能做更新操作，我已经获取了从共享锁到排他锁的资格。一个事物只能有一个更新锁获得资格
3.排他锁：（独占锁）其他事务既不能读，又不能排他锁定的资源
4.意向锁: 就是再屋(比如代表一个表)门口设置一个表示,说明屋子里有人(比如代表某些记录)被锁住了,另一个人想知道屋里是否有人被锁,不用一个个屋子去检查,直接看门口标识就行.</description>
    </item>
    
    <item>
      <title>C/C&#43;&#43;</title>
      <link>https://antoniodc-aaa.github.io/post/%E8%AF%AD%E8%A8%80/cc&#43;&#43;/</link>
      <pubDate>Tue, 24 Mar 2020 12:58:03 +0800</pubDate>
      
      <guid>https://antoniodc-aaa.github.io/post/%E8%AF%AD%E8%A8%80/cc&#43;&#43;/</guid>
      <description>C/C++ const
作用：1 修饰变量
​ 2 修饰指针
​ 3 修饰引用，指向常量的引用，用于形参类型，避免拷贝，又避免了函数对值的修改</description>
    </item>
    
    <item>
      <title>DLL</title>
      <link>https://antoniodc-aaa.github.io/post/%E9%A1%B9%E7%9B%AE/dll/</link>
      <pubDate>Mon, 23 Mar 2020 12:58:03 +0800</pubDate>
      
      <guid>https://antoniodc-aaa.github.io/post/%E9%A1%B9%E7%9B%AE/dll/</guid>
      <description>先测试测试呢</description>
    </item>
    
    <item>
      <title>DP与贪心</title>
      <link>https://antoniodc-aaa.github.io/post/%E7%AE%97%E6%B3%95/%E9%9A%8F%E7%AC%94/</link>
      <pubDate>Mon, 23 Mar 2020 12:58:03 +0800</pubDate>
      
      <guid>https://antoniodc-aaa.github.io/post/%E7%AE%97%E6%B3%95/%E9%9A%8F%E7%AC%94/</guid>
      <description>DP与贪心 question 1
哈夫曼编码
堆实现
question 2
做项目，获得利润
question 3</description>
    </item>
    
    <item>
      <title>Go tips</title>
      <link>https://antoniodc-aaa.github.io/post/%E8%AF%AD%E8%A8%80/go_tips/</link>
      <pubDate>Mon, 23 Mar 2020 12:58:03 +0800</pubDate>
      
      <guid>https://antoniodc-aaa.github.io/post/%E8%AF%AD%E8%A8%80/go_tips/</guid>
      <description>1.Go语言中
垃圾回收器知道一个变量 是否应该被回收。基本思路是每一个包级别的变量，以及每一个当前执行函数的局部变量，可以作为追溯变量的路径源头，通过指针和其他方式的引用可以找到变量。如果变量的路径不存在，那么变量变得不可访问，因此它不会影响任何其他的计算过程
2.多重赋值
思路上的转变
Go 常用的命令
build
install 与build最大的区别是编译后将输出文件打包库放在pkg下</description>
    </item>
    
    <item>
      <title>Linux命令</title>
      <link>https://antoniodc-aaa.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%8A%E5%AE%B9%E5%99%A8/linux%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Mon, 23 Mar 2020 12:58:03 +0800</pubDate>
      
      <guid>https://antoniodc-aaa.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%8A%E5%AE%B9%E5%99%A8/linux%E5%91%BD%E4%BB%A4/</guid>
      <description>Linux命令    Task Commands     进程控制 fork(); exit(); wait();   进程通信 pipe(); shmget(); mmap();   文件操作 open(); read(); write();   设备操作 ioctl(); read(); write();   信息维护 getpid(); alarm(); sleep();   安全 chmod(); umask(); chown();    进程之间的通信方式以及优缺点</description>
    </item>
    
    <item>
      <title>哈希表与B&#43;树</title>
      <link>https://antoniodc-aaa.github.io/post/%E7%AE%97%E6%B3%95/c&#43;&#43;%E5%BA%95%E5%B1%82/</link>
      <pubDate>Mon, 23 Mar 2020 12:58:03 +0800</pubDate>
      
      <guid>https://antoniodc-aaa.github.io/post/%E7%AE%97%E6%B3%95/c&#43;&#43;%E5%BA%95%E5%B1%82/</guid>
      <description>1.算法 哈希表 构造方法
 直接定值法 除留余数法 数字分析法 折叠法 平方取中法  冲突处理方法</description>
    </item>
    
    <item>
      <title>大数据</title>
      <link>https://antoniodc-aaa.github.io/post/%E7%AE%97%E6%B3%95/%E5%A4%A7%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Mon, 23 Mar 2020 12:58:03 +0800</pubDate>
      
      <guid>https://antoniodc-aaa.github.io/post/%E7%AE%97%E6%B3%95/%E5%A4%A7%E6%95%B0%E6%8D%AE/</guid>
      <description>大数据 Map-Reduce 和Hadoop逐渐成为面试热门
哈希函数的性质
1.典型的哈希函数都有无限的输入值域
2.输入值相同时，返回值一样
3.输入值不同时，返回值可能一样，也可能不一样
4.不同输入值的哈希值，整体均匀的分布在输入域s上（重要）
1-3性质是哈希函数的基础，第四点是评价一个哈希函数优劣的关键
MD5和SH1的算法都是经典的哈希算法</description>
    </item>
    
    <item>
      <title>左神的视频</title>
      <link>https://antoniodc-aaa.github.io/post/%E7%AE%97%E6%B3%95/%E5%B7%A6%E7%A5%9E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Mon, 23 Mar 2020 12:58:03 +0800</pubDate>
      
      <guid>https://antoniodc-aaa.github.io/post/%E7%AE%97%E6%B3%95/%E5%B7%A6%E7%A5%9E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>最小栈问题 准备 两个栈
一个放data元素
一个放data值的当前最小值
如何仅用队列结构实现栈结构 准备两个队列
其余元素放在data 队列中，剩下的哪一个元素放在head队列中
如何仅用栈结构实现队列结构 准备两个栈</description>
    </item>
    
    <item>
      <title>Git instructions</title>
      <link>https://antoniodc-aaa.github.io/post/%E5%85%B6%E4%BB%96/git/</link>
      <pubDate>Tue, 18 Feb 2020 18:02:14 +0800</pubDate>
      
      <guid>https://antoniodc-aaa.github.io/post/%E5%85%B6%E4%BB%96/git/</guid>
      <description>Git 集中式版本控制系统与分布式版本控制系统 集中式版本控制系统
​	有一个包含文件所有修订版本的单一服务器，多个客户端可以从这个中心位置检索出文件
优点：所有人都可以在一定程度上掌握其他人在项目中做了什么，管理员可以精细的掌控每个人的权限，
缺点：集中式服务器带来的单点故障
分布式版本控制系统
​	客户端并非仅仅是检出文件的最新快照，而是对代码仓库进行完整的镜像，不管是那个服务器出现故障，任何一个客户端都可以使用自己的本地镜像来恢复服务器，每一次检出操作实际上都是对数据的一次完整备份。</description>
    </item>
    
    <item>
      <title>线程池和无锁队列实现并发</title>
      <link>https://antoniodc-aaa.github.io/post/%E5%85%B6%E4%BB%96/%E5%B9%B6%E5%8F%91/</link>
      <pubDate>Sat, 18 Jan 2020 18:18:08 +0800</pubDate>
      
      <guid>https://antoniodc-aaa.github.io/post/%E5%85%B6%E4%BB%96/%E5%B9%B6%E5%8F%91/</guid>
      <description>通过一个在项目中使用的服务器编程的例子，记录一下怎样通过线程池和原子操作实现并发编程 原始模型是：一个生产者，一个缓存队列，两个消费者，一个条件变量。 线程池模型是：线程池中的线程做生产者，分别绑定一个缓存队列，每个缓存队列绑定两个消费者 工作过程：线程池中的线程将数据写入自己绑定的队列中，当缓存到达一半时，使用条件变量唤醒两个消费者，迅速将数据消费完 缓存队列的读写指针，使用C++11的原子变量，保证两个写者之间的同步。
#define pack_max 512*1024*1024struct myatomic { atomic_int rd; atomic_int wd: }; struct myCmd { int cmd; char buf[50]; string ip; }; //共享变量 myatomic ato_rw1{0,0}; myCmd Buffer1[pack_max]; //生产者 void creator(string ip,int fd) { char buf1[50]; read(fd,buf1,len); myCmd inbuf; //填充inbuf 	//.</description>
    </item>
    
    <item>
      <title>Mysql</title>
      <link>https://antoniodc-aaa.github.io/post/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/</link>
      <pubDate>Thu, 12 Dec 2019 10:07:12 +0800</pubDate>
      
      <guid>https://antoniodc-aaa.github.io/post/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/</guid>
      <description>Mysql 当连接数据库时   管理器首先检查你的验证信息（用户名和密码），然后检查你 是否有访问数据库的授权。这些权限由DBA分配
  然后，管理器检查是否由空闲进程（或线程）来处理你的查询
  管理器还会检查数据库是否负载很重</description>
    </item>
    
    <item>
      <title>Linux Points</title>
      <link>https://antoniodc-aaa.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%8A%E5%AE%B9%E5%99%A8/linux-points/</link>
      <pubDate>Thu, 15 Aug 2019 08:08:30 +0800</pubDate>
      
      <guid>https://antoniodc-aaa.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%8A%E5%AE%B9%E5%99%A8/linux-points/</guid>
      <description>Linux Points  能够简单使用cat，grep，cut等命令进行一些操作； 文件系统相关的原理，inode 和block等概念，数据恢复； 硬链接与软链接 进程管理相关，僵尸进程与孤儿进程，SIGCHLD  文件系统 分区与文件系统 对分区进行格式化是为了在分区上建立文件系统。一个分区通常只能格式化一个文件系统，但是磁盘阵列技术可以将一个分区格式化多个文件系统</description>
    </item>
    
    <item>
      <title>Docker简介</title>
      <link>https://antoniodc-aaa.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%8A%E5%AE%B9%E5%99%A8/docker%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Mon, 12 Aug 2019 08:08:30 +0800</pubDate>
      
      <guid>https://antoniodc-aaa.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8F%8A%E5%AE%B9%E5%99%A8/docker%E7%AE%80%E4%BB%8B/</guid>
      <description>Docker Docker时一个开源的应用容器引擎它让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到安装了任何Linux发行版本的机器上。
Docker时直接运行在宿主操作系统上的一个容器，使用沙箱机制完全虚拟出一个完整的操作，容器之间不会有任何接口，从而让容器与宿主机之间、容器与容器之间的隔离更加彻底。每个容器都有自己的权限管理，独立的网络与存储栈，以及自己的资源管理能，使同一台宿主机上可以友好的共存多个容器
1.从传统观点上看，容器不是虚拟机，虚拟机中包含完整的操作系统，运行在宿主操作系统之上，虚拟机的优点在于在一台宿主机中，可以使用虚拟机运行多个完全不同的操作系统。对于容器来说，宿主机和容器共用一个内核，容器使用的系统资源更少，但是必须基于相同的底层操作系统 Docker只能在已经安装Ｄocker的宿主机器上部署、运行和管理容器，不能创建新的宿主系统（实例）、对象存储器和块存储器，以及通常与云平台有关的很多其他资源 虽然Docker 能提升组织管理应用和应用依赖的能力，但是不能完全取代更为传统的配置管理工具。Ｄockerfile文件用于定义构建时容器里的内容，但是不能持续管理容器的状态，也不能用于管理Ｄocker宿主系统
Ｄｏｃｋｅｒ架构 基础架构是简单的客户端－服务器模型。ｄｏｃｋｅｒ只提供一个可执行文件，既可以用作客户端，也可以用作服务器。具体是那个，取决于执行ｄｏｃｋｅｒ命令的方式。
Docker基本上有两部分组成，客户端和服务器（守护进程），还有一个可选的注册处，用于存储ｄｏｃｋｅｒ映像和映像的元数据，服务器用作持续运行和管理容器，客户端的作用是告诉服务器要做什么事。 Ｄｏｃｋｅｒ服务器可以直接连接映像注册处，客户端的职责是控制服务器做什么事情，而服务器则专注于存储容器化应用</description>
    </item>
    
    <item>
      <title>sorts</title>
      <link>https://antoniodc-aaa.github.io/post/%E5%85%B6%E4%BB%96/sorts/</link>
      <pubDate>Sat, 18 May 2019 17:40:00 +0800</pubDate>
      
      <guid>https://antoniodc-aaa.github.io/post/%E5%85%B6%E4%BB%96/sorts/</guid>
      <description>冒泡排序 每次外循环都能确定数组的最大值
func BubbleSort(nums []int){ if nums == nil || len(nums) &amp;lt; 2{ return } for i:=len(nums)-1;i&amp;gt;=0;i--{ for j:=0;j&amp;lt;i;j++{ if nums[j] &amp;gt; nums[j+1]{ nums[j],nums[j+1] = nums[j+1],nums[j] } } } fmt.</description>
    </item>
    
    <item>
      <title>EffectiveCPP</title>
      <link>https://antoniodc-aaa.github.io/post/%E8%AF%AD%E8%A8%80/effectivecpp/</link>
      <pubDate>Sun, 11 Nov 2018 10:29:41 +0800</pubDate>
      
      <guid>https://antoniodc-aaa.github.io/post/%E8%AF%AD%E8%A8%80/effectivecpp/</guid>
      <description>Effective C++  视 C++ 为一个语言联邦（C、Object-Oriented C++、Template C++、STL） 宁可以编译器替换预处理器（尽量以 const、enum、inline 替换 #define） 尽可能使用 const 确定对象被使用前已先被初始化（构造时赋值（copy 构造函数）比 default 构造后赋值（copy assignment）效率高） 了解 C++ 默默编写并调用哪些函数（编译器暗自为 class 创建 default 构造函数、copy 构造函数、copy assignment 操作符、析构函数） 若不想使用编译器自动生成的函数，就应该明确拒绝（将不想使用的成员函数声明为 private，并且不予实现） 为多态基类声明 virtual 析构函数（如果 class 带有任何 virtual 函数，它就应该拥有一个 virtual 析构函数） 别让异常逃离析构函数（析构函数应该吞下不传播异常，或者结束程序，而不是吐出异常；如果要处理异常应该在非析构的普通函数处理） 绝不在构造和析构过程中调用 virtual 函数（因为这类调用从不下降至 derived class） 令 operator= 返回一个 reference to *this （用于连锁赋值） 在 operator= 中处理 “自我赋值” 赋值对象时应确保复制 “对象内的所有成员变量” 及 “所有 base class 成分”（调用基类复制构造函数） 以对象管理资源（资源在构造函数获得，在析构函数释放，建议使用智能指针，资源取得时机便是初始化时机（Resource Acquisition Is Initialization，RAII）） 在资源管理类中小心 copying 行为（普遍的 RAII class copying 行为是：抑制 copying、引用计数、深度拷贝、转移底部资源拥有权（类似 auto_ptr）） 在资源管理类中提供对原始资源（raw resources）的访问（对原始资源的访问可能经过显式转换或隐式转换，一般而言显示转换比较安全，隐式转换对客户比较方便） 成对使用 new 和 delete 时要采取相同形式（new 中使用 [] 则 delete []，new 中不使用 [] 则 delete） 以独立语句将 newed 对象存储于（置入）智能指针（如果不这样做，可能会因为编译器优化，导致难以察觉的资源泄漏） 让接口容易被正确使用，不易被误用（促进正常使用的办法：接口的一致性、内置类型的行为兼容；阻止误用的办法：建立新类型，限制类型上的操作，约束对象值、消除客户的资源管理责任） 设计 class 犹如设计 type，需要考虑对象创建、销毁、初始化、赋值、值传递、合法值、继承关系、转换、一般化等等。 宁以 pass-by-reference-to-const 替换 pass-by-value （前者通常更高效、避免切割问题（slicing problem），但不适用于内置类型、STL迭代器、函数对象） 必须返回对象时，别妄想返回其 reference（绝不返回 pointer 或 reference 指向一个 local stack 对象，或返回 reference 指向一个 heap-allocated 对象，或返回 pointer 或 reference 指向一个 local static 对象而有可能同时需要多个这样的对象。） 将成员变量声明为 private（为了封装、一致性、对其读写精确控制等） 宁以 non-member、non-friend 替换 member 函数（可增加封装性、包裹弹性（packaging flexibility）、机能扩充性） 若所有参数（包括被this指针所指的那个隐喻参数）皆须要类型转换，请为此采用 non-member 函数 考虑写一个不抛异常的 swap 函数 尽可能延后变量定义式的出现时间（可增加程序清晰度并改善程序效率） 尽量少做转型动作（旧式：(T)expression、T(expression)；新式：const_cast(expression)、dynamic_cast(expression)、reinterpret_cast(expression)、static_cast(expression)、；尽量避免转型、注重效率避免 dynamic_casts、尽量设计成无需转型、可把转型封装成函数、宁可用新式转型） 避免使用 handles（包括 引用、指针、迭代器）指向对象内部（以增加封装性、使 const 成员函数的行为更像 const、降低 “虚吊号码牌”（dangling handles，如悬空指针等）的可能性） 为 “异常安全” 而努力是值得的（异常安全函数（Exception-safe functions）即使发生异常也不会泄露资源或允许任何数据结构败坏，分为三种可能的保证：基本型、强列型、不抛异常型） 透彻了解 inlining 的里里外外（inlining 在大多数 C++ 程序中是编译期的行为；inline 函数是否真正 inline，取决于编译器；大部分编译器拒绝太过复杂（如带有循环或递归）的函数 inlining，而所有对 virtual 函数的调用（除非是最平淡无奇的）也都会使 inlining 落空；inline 造成的代码膨胀可能带来效率损失；inline 函数无法随着程序库的升级而升级） 将文件间的编译依存关系降至最低（如果使用 object references 或 object pointers 可以完成任务，就不要使用 objects；如果能够，尽量以 class 声明式替换 class 定义式；为声明式和定义式提供不同的头文件） 确定你的 public 继承塑模出 is-a（是一种）关系（适用于 base classes 身上的每一件事情一定适用于 derived classes 身上，因为每一个 derived class 对象也都是一个 base class 对象） 避免遮掩继承而来的名字（可使用 using 声明式或转交函数（forwarding functions）来让被遮掩的名字再见天日） 区分接口继承和实现继承（在 public 继承之下，derived classes 总是继承 base class 的接口；pure virtual 函数只具体指定接口继承；非纯 impure virtual 函数具体指定接口继承及缺省实现继承；non-virtual 函数具体指定接口继承以及强制性实现继承） 考虑 virtual 函数以外的其他选择（如 Template Method 设计模式的 non-virtual interface（NVI）手法，将 virtual 函数替换为 “函数指针成员变量”，以 tr1::function 成员变量替换 virtual 函数，将继承体系内的 virtual 函数替换为另一个继承体系内的 virtual 函数） 绝不重新定义继承而来的 non-virtual 函数 绝不重新定义继承而来的缺省参数值，因为缺省参数值是静态绑定（statically bound），而 virtual 函数却是动态绑定（dynamically bound） 通过复合塑模 has-a（有一个）或 “根据某物实现出”（在应用域（application domain），复合意味 has-a（有一个）；在实现域（implementation domain），复合意味着 is-implemented-in-terms-of（根据某物实现出）） 明智而审慎地使用 private 继承（private 继承意味着 is-implemented-in-terms-of（根据某物实现出），尽可能使用复合，当 derived class 需要访问 protected base class 的成员，或需要重新定义继承而来的时候 virtual 函数，或需要 empty base 最优化时，才使用 private 继承） 明智而审慎地使用多重继承（多继承比单一继承复杂，可能导致新的歧义性，以及对 virtual 继承的需要，但确有正当用途，如 “public 继承某个 interface class” 和 “private 继承某个协助实现的 class”；virtual 继承可解决多继承下菱形继承的二义性问题，但会增加大小、速度、初始化及赋值的复杂度等等成本） 了解隐式接口和编译期多态（class 和 templates 都支持接口（interfaces）和多态（polymorphism）；class 的接口是以签名为中心的显式的（explicit），多态则是通过 virtual 函数发生于运行期；template 的接口是奠基于有效表达式的隐式的（implicit），多态则是通过 template 具现化和函数重载解析（function overloading resolution）发生于编译期） 了解 typename 的双重意义（声明 template 类型参数是，前缀关键字 class 和 typename 的意义完全相同；请使用关键字 typename 标识嵌套从属类型名称，但不得在基类列（base class lists）或成员初值列（member initialization list）内以它作为 base class 修饰符） 学习处理模板化基类内的名称（可在 derived class templates 内通过 this-&amp;gt; 指涉 base class templates 内的成员名称，或藉由一个明白写出的 “base class 资格修饰符” 完成） 将与参数无关的代码抽离 templates（因类型模板参数（non-type template parameters）而造成代码膨胀往往可以通过函数参数或 class 成员变量替换 template 参数来消除；因类型参数（type parameters）而造成的代码膨胀往往可以通过让带有完全相同二进制表述（binary representations）的实现类型（instantiation types）共享实现码） 运用成员函数模板接受所有兼容类型（请使用成员函数模板（member function templates）生成 “可接受所有兼容类型” 的函数；声明 member templates 用于 “泛化 copy 构造” 或 “泛化 assignment 操作” 时还需要声明正常的 copy 构造函数和 copy assignment 操作符） 需要类型转换时请为模板定义非成员函数（当我们编写一个 class template，而它所提供之 “与此 template 相关的” 函数支持 “所有参数之隐式类型转换” 时，请将那些函数定义为 “class template 内部的 friend 函数”） 请使用 traits classes 表现类型信息（traits classes 通过 templates 和 “templates 特化” 使得 “类型相关信息” 在编译期可用，通过重载技术（overloading）实现在编译期对类型执行 if&amp;hellip;else 测试） 认识 template 元编程（模板元编程（TMP，template metaprogramming）可将工作由运行期移往编译期，因此得以实现早期错误侦测和更高的执行效率；TMP 可被用来生成 “给予政策选择组合”（based on combinations of policy choices）的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码） 了解 new-handler 的行为（set_new_handler 允许客户指定一个在内存分配无法获得满足时被调用的函数；nothrow new 是一个颇具局限的工具，因为它只适用于内存分配（operator new），后继的构造函数调用还是可能抛出异常） 了解 new 和 delete 的合理替换时机（为了检测运用错误、收集动态分配内存之使用统计信息、增加分配和归还速度、降低缺省内存管理器带来的空间额外开销、弥补缺省分配器中的非最佳齐位、将相关对象成簇集中、获得非传统的行为） 编写 new 和 delete 时需固守常规（operator new 应该内涵一个无穷循环，并在其中尝试分配内存，如果它无法满足内存需求，就应该调用 new-handler，它也应该有能力处理 0 bytes 申请，class 专属版本则还应该处理 “比正确大小更大的（错误）申请”；operator delete 应该在收到 null 指针时不做任何事，class 专属版本则还应该处理 “比正确大小更大的（错误）申请”） 写了 placement new 也要写 placement delete（当你写一个 placement operator new，请确定也写出了对应的 placement operator delete，否则可能会发生隐微而时断时续的内存泄漏；当你声明 placement new 和 placement delete，请确定不要无意识（非故意）地遮掩了它们地正常版本） 不要轻忽编译器的警告 让自己熟悉包括 TR1 在内的标准程序库（TR1，C++ Technical Report 1，C++11 标准的草稿文件） 让自己熟悉 Boost（准标准库）  More Effective c++  仔细区别 pointers 和 references（当你知道你需要指向某个东西，而且绝不会改变指向其他东西，或是当你实现一个操作符而其语法需求无法由 pointers 达成，你就应该选择 references；任何其他时候，请采用 pointers） 最好使用 C++ 转型操作符（static_cast、const_cast、dynamic_cast、reinterpret_cast） 绝不要以多态（polymorphically）方式处理数组（多态（polymorphism）和指针算术不能混用；数组对象几乎总是会涉及指针的算术运算，所以数组和多态不要混用） 非必要不提供 default constructor（避免对象中的字段被无意义地初始化） 对定制的 “类型转换函数” 保持警觉（单自变量 constructors 可通过简易法（explicit 关键字）或代理类（proxy classes）来避免编译器误用；隐式类型转换操作符可改为显式的 member function 来避免非预期行为） 区别 increment/decrement 操作符的前置（prefix）和后置（postfix）形式（前置式累加后取出，返回一个 reference；后置式取出后累加，返回一个 const 对象；处理用户定制类型时，应该尽可能使用前置式 increment；后置式的实现应以其前置式兄弟为基础） 千万不要重载 &amp;amp;&amp;amp;，|| 和 , 操作符（&amp;amp;&amp;amp; 与 || 的重载会用 “函数调用语义” 取代 “骤死式语义”；, 的重载导致不能保证左侧表达式一定比右侧表达式更早被评估） 了解各种不同意义的 new 和 delete（new operator、operator new、placement new、operator new[]；delete operator、operator delete、destructor、operator delete[]） 利用 destructors 避免泄漏资源（在 destructors 释放资源可以避免异常时的资源泄漏） 在 constructors 内阻止资源泄漏（由于 C++ 只会析构已构造完成的对象，因此在构造函数可以使用 try&amp;hellip;catch 或者 auto_ptr（以及与之相似的 classes） 处理异常时资源泄露问题） 禁止异常流出 destructors 之外（原因：一、避免 terminate 函数在 exception 传播过程的栈展开（stack-unwinding）机制种被调用；二、协助确保 destructors 完成其应该完成的所有事情） 了解 “抛出一个 exception” 与 “传递一个参数” 或 “调用一个虚函数” 之间的差异（第一，exception objects 总是会被复制（by pointer 除外），如果以 by value 方式捕捉甚至被复制两次，而传递给函数参数的对象则不一定得复制；第二，“被抛出成为 exceptions” 的对象，其被允许的类型转换动作比 “被传递到函数去” 的对象少；第三，catch 子句以其 “出现于源代码的顺序” 被编译器检验对比，其中第一个匹配成功者便执行，而调用一个虚函数，被选中执行的是那个 “与对象类型最佳吻合” 的函数） 以 by reference 方式捕获 exceptions（可避免对象删除问题、exception objects 的切割问题，可保留捕捉标准 exceptions 的能力，可约束 exception object 需要复制的次数） 明智运用 exception specifications（exception specifications 对 “函数希望抛出什么样的 exceptions” 提供了卓越的说明；也有一些缺点，包括编译器只对它们做局部性检验而很容易不经意地违反，与可能会妨碍更上层的 exception 处理函数处理未预期的 exceptions） 了解异常处理的成本（粗略估计，如果使用 try 语句块，代码大约整体膨胀 5%-10%，执行速度亦大约下降这个数；因此请将你对 try 语句块和 exception specifications 的使用限制于非用不可的地点，并且在真正异常的情况下才抛出 exceptions） 谨记 80-20 法则（软件的整体性能几乎总是由其构成要素（代码）的一小部分决定的，可使用程序分析器（program profiler）识别出消耗资源的代码） 考虑使用 lazy evaluation（缓式评估）（可应用于：Reference Counting（引用计数）来避免非必要的对象复制、区分 operator[] 的读和写动作来做不同的事情、Lazy Fetching（缓式取出）来避免非必要的数据库读取动作、Lazy Expression Evaluation（表达式缓评估）来避免非必要的数值计算动作） 分期摊还预期的计算成本（当你必须支持某些运算而其结构几乎总是被需要，或其结果常常被多次需要的时候，over-eager evaluation（超急评估）可以改善程序效率）  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://antoniodc-aaa.github.io/post/%E5%85%B6%E4%BB%96/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/gohttp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://antoniodc-aaa.github.io/post/%E5%85%B6%E4%BB%96/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/gohttp/</guid>
      <description>title: &amp;ldquo;Go-engine.IO&amp;rdquo; date: 2019-10-23T017:07:30+08:00 draft: true tags: Go语言源码阅读 keywords: Go</description>
    </item>
    
    <item>
      <title>Buffer包</title>
      <link>https://antoniodc-aaa.github.io/post/%E5%85%B6%E4%BB%96/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/%E8%87%AA%E5%B8%A6%E5%BA%93/buffer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://antoniodc-aaa.github.io/post/%E5%85%B6%E4%BB%96/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/%E8%87%AA%E5%B8%A6%E5%BA%93/buffer/</guid>
      <description>bytes包中的buffer Buffer是一个实现了读写方法的可变大小的字节缓冲。本类型的零值是一个空的可用于读写的缓冲。
1.初始化的最小内存是64字节
// smallBufferSize is an initial allocation minimal capacity.</description>
    </item>
    
    <item>
      <title>C&#43;&#43;虚函数与纯虚函数的区别</title>
      <link>https://antoniodc-aaa.github.io/post/%E8%AF%AD%E8%A8%80/c&#43;&#43;/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://antoniodc-aaa.github.io/post/%E8%AF%AD%E8%A8%80/c&#43;&#43;/</guid>
      <description>C++ 虚函数与纯虚函数的区别   虚函数和纯虚函数可以定义在同一个类中，含有纯虚函数的类叫做抽象类，而只含有虚函数的类不能称为抽象类
  虚函数可以被直接使用，也可以被子类（sub class）重载以后以多态的形式调用，而纯虚函数必须在子类中实现该函数才能使用，因为纯虚函数在基类只有声明，没有定义
  虚函数和纯虚函数都可以在子类中被重载，以多态的形式调用</description>
    </item>
    
    <item>
      <title>Chitchat</title>
      <link>https://antoniodc-aaa.github.io/post/%E5%85%B6%E4%BB%96/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/chitchat/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://antoniodc-aaa.github.io/post/%E5%85%B6%E4%BB%96/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/chitchat/</guid>
      <description>Chitchat 19.11.26日开始看源码
简介 一个轻量级的支持高并发的通信库框架，基于goland socket
对于服务器和用户来说需要做的只有三步
1.配置监听地址
2.编写读处理函数
3.正确对待错误处理
使用 服务器接口 type Server interface { Listen() error Cut() error	//CAD::终止监听  CloseRemote(string) error	//CAD:关闭连接  RangeRemoteAddr() []string //CAD:返回所有的连接 	GetLocalAddr() string SetDeadLine(time.</description>
    </item>
    
    <item>
      <title>Effective Go</title>
      <link>https://antoniodc-aaa.github.io/post/%E5%85%B6%E4%BB%96/go%E8%AF%AD%E8%A8%80/effective-go/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://antoniodc-aaa.github.io/post/%E5%85%B6%E4%BB%96/go%E8%AF%AD%E8%A8%80/effective-go/</guid>
      <description>Effective Go 1.长命名并不会使其更具有可读性。一份有用的说明文档通常比额外的长命更有价值
2.Go并不对获取器（getter）和设置器（setter）提供自动支持。Get放在获取器的名字中，既不符合习惯，也不必要。如果有个名为ower的字段，获取器应为Ower（大写，可导出），而非GetOwer
若要提供设置器的方法，SetOwer是个不错的选择
3.和C一样，Go的正式语法使用分号来结束语句；和C不同的时，这些分号并不出现在源码中。取而代之，词法分析器会使用一条简单的规则来自动插入分号，因此源码中基本就不用分号了。
4.Go语言只有for swtich，if ，此外还有一个包含类型选择和多路复用通信复用器的新结构：select
5.</description>
    </item>
    
    <item>
      <title>GoSocket</title>
      <link>https://antoniodc-aaa.github.io/post/%E5%85%B6%E4%BB%96/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/gosocket/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://antoniodc-aaa.github.io/post/%E5%85%B6%E4%BB%96/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/gosocket/</guid>
      <description>Go语言github
// onceCloseListener wraps a net.Listener, protecting it from // multiple Close calls.</description>
    </item>
    
    <item>
      <title>Go语言</title>
      <link>https://antoniodc-aaa.github.io/post/%E5%85%B6%E4%BB%96/go%E8%AF%AD%E8%A8%80/go/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://antoniodc-aaa.github.io/post/%E5%85%B6%E4%BB%96/go%E8%AF%AD%E8%A8%80/go/</guid>
      <description>Go 当内置的panic()函数调用时，外围函数或方法的执行会立即终止。然后，任何延迟执行(defer)的函数或方法都会被调用，就像其外围函数正常返回一样。最后，调用返回到该外围函数的调用者，就像该外围调用函数或方法调用了panic()一样，因此该过程一直在调用栈中重复发生：函数停止执行，调用延迟执行函数等。当到达main()函数时不再有可以返回的调用者，因此这个过程会终止，并将包含传入原始panic()函数中的值的调用栈信息输出到os.Stderr。
panic需要等defer结束后才会向上传递。出现panic的时候，会先按照defer的后入先出的顺序执行，最后才会执行panic。
全局变量要定义在函数之外，而在函数之外定义的变量只****能用var定义。
go语言编译器会自动在以标识符、数字字面量、字母字面量、字符串字面量、特定的关键字（break、continue、fallthrough和return）、增减操作符（++和&amp;ndash;）、或者一个右括号、右方括号和右大括号（即)、]、}）结束的非空行的末尾自动加上分号。
/*
func isCycle(head *ListNode)*ListNode{
if head == nil || head.</description>
    </item>
    
    <item>
      <title>Go语言中TCP Server</title>
      <link>https://antoniodc-aaa.github.io/post/%E5%85%B6%E4%BB%96/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80tcpserver/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://antoniodc-aaa.github.io/post/%E5%85%B6%E4%BB%96/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80tcpserver/</guid>
      <description>Go语言中TCP Server 参考博客 https://blog.csdn.net/kenkao/article/details/94715207
go tcp server的四种处理机制 由于go语言协程的特性，比线程更小。执行goroutine只需要极少的栈内存（大约只有4-5KB）。所以常规的监听socket并执行为如下代码。这也是书中或其他博客常见的场景
//CAD::监听端口ln, err := net.</description>
    </item>
    
    <item>
      <title>Go语言后端基础</title>
      <link>https://antoniodc-aaa.github.io/post/%E5%85%B6%E4%BB%96/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E5%90%8E%E7%AB%AF%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://antoniodc-aaa.github.io/post/%E5%85%B6%E4%BB%96/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E5%90%8E%E7%AB%AF%E5%9F%BA%E7%A1%80/</guid>
      <description>Go语言后端基础 Go语言不需要nginx、apache服务器，因为他直接就监听tcp端口，做了nginx的事情，因为go语言的socket底层也是epoll模型
Web工作方式的几个概念   Request：用户请求的信息，用来解析用户的请求信息，包括post、get、cookie、url等信息
  Response：服务器需要反馈给客户端的信息
  Conn：用户的每次请求链接</description>
    </item>
    
    <item>
      <title>Go语言后端基础</title>
      <link>https://antoniodc-aaa.github.io/post/%E5%85%B6%E4%BB%96/go%E8%AF%AD%E8%A8%80/soap%E4%B8%8Erest/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://antoniodc-aaa.github.io/post/%E5%85%B6%E4%BB%96/go%E8%AF%AD%E8%A8%80/soap%E4%B8%8Erest/</guid>
      <description>基于SOAP是功能驱动
基于REST是数据驱动
基于SOAP的web服务往往是RPC风格
基于REST的web服务关注的是资源
SOAP是一种协议，用于交换定义在XML里面的结构化数据，能够跨越不同的网络协议并在不同的编程模型中使用。SOAP是Simple Object Access Protocal(简单对象访问协议)
SOAP会将它的报文内容放在信封里面，信封相当于一个运输容器，并且它还能独立于实际的数据传输方式存在。
REST（Representational State Transfer）具象状态传输</description>
    </item>
    
    <item>
      <title>Http</title>
      <link>https://antoniodc-aaa.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/http/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://antoniodc-aaa.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/http/</guid>
      <description>1.URL中?,#,&amp;amp; URL中#代表网页中出现的一个位置。右边的字符就是该位置的标识符，这些字符不会发送到服务器端,浏览器只会滚动到相应的位置，不会重新夹在网页
#URL是用来知道浏览器动作的，对服务器端完全无用
?连接作用，通过？带来参数和连接域名
清除缓存
&amp;amp;连接不同的参数
Session会话控制 Session对象存储特定用户会话所需要的属性及配置信息，当用户在应用程序的Web页之间跳转时，存储在Session对象的变量将不会丢失，在整个用户会话中一直存在下去
会话Session跟踪；会话指的是用户登陆网站后的一系列动作，会话跟踪是Web程序常用的技术，用来跟踪用户的整个会话，常用的会话跟踪技术是Cookie与Session，Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录确定用户身份
Cookie是一小段的文本信息，客户端请求服务器，如果服务器需要记录该用户状态，使用reponse向客户端浏览器颁发一个Cookie。客户端会把Cookie保存起来，当浏览器再次请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以据此来辨认用户状态。服务器还可以根据需要修改Cookie的内容</description>
    </item>
    
    <item>
      <title>Http</title>
      <link>https://antoniodc-aaa.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/http%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://antoniodc-aaa.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/http%E7%AE%80%E4%BB%8B/</guid>
      <description>输入URL执行过程（一次完整的http请求过程） DHCP配置主机信息 假设主机最开始没有IP地址以及其他信息，需要先使用DHCP来获取
 主机生成一个DHCP请求报文，并将这个报文放具有目的端口67和68的UDP报文端中 该报文段会被放入一个具有广播IP目地址（255.255.255.255）和源地址（0.0.0.0）的IP数据报中 该数据报则被放置在MAC帧中，该帧具有目的地址FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备 连接在交换机的DHCP服务器收到广播帧之后，不断向上分解得到IP数据报，UDP报文端，DHCP请求报文，之后生成DHCP ACK报文，该报文包含以下信息：IP地址、DNS服务器的IP地址、默认网关路由器的IP地址和子网掩码 。该报文被放入UDP报文段中，UDP报文段有被放入IP数据报中年，最后放入MAC帧中 该帧的目的地址式请求主机的MAC地址，因为交换机具有自主学习能力，之前主机发送了广播帧之后就记录了MAC地址到转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧 主机收到该帧之后，不断分解得到DHCP报文。之后配置它的IP地址、子网掩码和DNS服务器的IP地址，并在其IP转发表中安装默认网关。  ARP解析MAC地址 主机通过浏览器生成一个TCP套接字，套接字向HTTP服务器发送HTTP请求，为了生成套接字，主机需要知道网站域名对应的IP地址。因为DHCP只是知道DNS服务器的IP地址，对应的需要先知道网关路由器的MAC地址。</description>
    </item>
    
    <item>
      <title>IO多路复用</title>
      <link>https://antoniodc-aaa.github.io/post/%E5%85%B6%E4%BB%96/go%E8%AF%AD%E8%A8%80/io/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://antoniodc-aaa.github.io/post/%E5%85%B6%E4%BB%96/go%E8%AF%AD%E8%A8%80/io/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E6%9C%BA%E5%88%B6/</guid>
      <description>IO多路复用的三种机制 IO多路复用（multiplexing）的本质是通过一种机制（系统内核缓冲I/O数据），让单个进程可以监视多个文件描述符，一旦某个描述符就绪（一般是读就绪或者是写就绪），就能够通知程序进行相应的读写操作
Unix五种IO模型 简述 [1] blocking IO - 阻塞IO [2] nonblocking IO - 非阻塞IO [3] IO multiplexing - IO多路复用 [4] signal driven IO - 信号驱动IO [5] asynchronous IO - 异步IO</description>
    </item>
    
    <item>
      <title>IO技术</title>
      <link>https://antoniodc-aaa.github.io/post/%E5%85%B6%E4%BB%96/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F/io/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://antoniodc-aaa.github.io/post/%E5%85%B6%E4%BB%96/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F/io/</guid>
      <description>IO技术 《./操作系统/IO多路复用的三种机制》讲述了Linux下5种IO模型
阻塞和非阻塞是指当进程访问的数据如果尚未就绪,进程是否需要等待,简单说这相当于函数内部的实现区别,也就是未就绪时是直接返回还是等待就绪;
同步和异步是指的访问数据的机制，同步指的是主动请求并等待I/O完毕的方式，当数据就绪后在读写的时候必须阻塞（区别就绪与读写两个阶段，同步的读写必须阻塞），异步则是指主动请求数据后便可以继续处理其他任务，随后等待I/O，操作完毕的通知，这可以使得进程在数据读写时不阻塞（等待通知）
IO写的四种方法（简单文件写） //方法 1 io.WriteString(f, wireteString)	//f：文件句柄，Str:要写的 //方法 2 ioutil.</description>
    </item>
    
    <item>
      <title>IO技术</title>
      <link>https://antoniodc-aaa.github.io/post/%E5%85%B6%E4%BB%96/go%E8%AF%AD%E8%A8%80/io/io/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://antoniodc-aaa.github.io/post/%E5%85%B6%E4%BB%96/go%E8%AF%AD%E8%A8%80/io/io/</guid>
      <description>IO技术 《./操作系统/IO多路复用的三种机制》讲述了Linux下5种IO模型
阻塞和非阻塞是指当进程访问的数据如果尚未就绪,进程是否需要等待,简单说这相当于函数内部的实现区别,也就是未就绪时是直接返回还是等待就绪;
同步和异步是指的访问数据的机制，同步指的是主动请求并等待I/O完毕的方式，当数据就绪后在读写的时候必须阻塞（区别就绪与读写两个阶段，同步的读写必须阻塞），异步则是指主动请求数据后便可以继续处理其他任务，随后等待I/O，操作完毕的通知，这可以使得进程在数据读写时不阻塞（等待通知）
IO写的四种方法（简单文件写） //方法 1 io.WriteString(f, wireteString)	//f：文件句柄，Str:要写的 //方法 2 ioutil.</description>
    </item>
    
    <item>
      <title>Kafka</title>
      <link>https://antoniodc-aaa.github.io/post/%E5%85%B6%E4%BB%96/go%E8%AF%AD%E8%A8%80/kafka/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://antoniodc-aaa.github.io/post/%E5%85%B6%E4%BB%96/go%E8%AF%AD%E8%A8%80/kafka/</guid>
      <description>kafka Kafka是一个分布式、分区的、多副本的、多订阅者，基于zookeeper协调的分布式日至系统，常见可用于web/nginx日志，访问日志、消息服务等
Kafka主要设计目标如下：
 以时间复杂度为O(1)的方式提供消息持久化能力，即使对TB级以上数据也能保证常数时间的访问性能。 高吞吐率。即使在非常廉价的商用机器上也能做到单机支持每秒100K条消息的传输。 支持Kafka Server间的消息分区，及分布式消费，同时保证每个partition内的消息顺序传输。 同时支持离线数据处理和实时数据处理。 Scale out:支持在线水平扩展  消息系统介绍 ​	有两种消息传递模式：点对点传递模式、发布-订阅模式</description>
    </item>
    
    <item>
      <title>Slice包</title>
      <link>https://antoniodc-aaa.github.io/post/%E5%85%B6%E4%BB%96/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/%E8%87%AA%E5%B8%A6%E5%BA%93/slice/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://antoniodc-aaa.github.io/post/%E5%85%B6%E4%BB%96/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/%E8%87%AA%E5%B8%A6%E5%BA%93/slice/</guid>
      <description>Slice 基础的数据类型在runtime包里
19.11.27
昨天看到对buffer的增长，今天看看对slice的增长
切片的内部结构 栈内存 type slice struct { array unsafe.</description>
    </item>
    
    <item>
      <title>STL</title>
      <link>https://antoniodc-aaa.github.io/post/%E8%AF%AD%E8%A8%80/stl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://antoniodc-aaa.github.io/post/%E8%AF%AD%E8%A8%80/stl/</guid>
      <description>STL源码剖析 &amp;mdash;侯捷 使用一个东西，却不明白它的道理，不高明
体系结构与内核分析 所谓GP泛型编程，就是使用模板template为主要工具来编写程序
目标 level 0：使用C++标准库
level 1：认识C++标准库（胸中自有丘壑）</description>
    </item>
    
    <item>
      <title>STL标准库</title>
      <link>https://antoniodc-aaa.github.io/post/%E8%AF%AD%E8%A8%80/stl%E6%A0%87%E5%87%86%E5%BA%93/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://antoniodc-aaa.github.io/post/%E8%AF%AD%E8%A8%80/stl%E6%A0%87%E5%87%86%E5%BA%93/</guid>
      <description>STL标准库 六大部件 容器
分配器
算法
迭代器
适配器
仿函式
有序容器 array</description>
    </item>
    
    <item>
      <title>Test</title>
      <link>https://antoniodc-aaa.github.io/post/%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://antoniodc-aaa.github.io/post/%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80test/</guid>
      <description>Go语言Test t.Errorf为打印错误信息，并且当前test case 会被跳过
go的test不会保证多个testXxx会顺序执行
如果要顺序执行，使用t.Run来执行subtests可以做到控制test输出以及test的顺序
TestMain作为初始化test，并且使用m.Run()来调用其他tests金额以完成一些需要初始化操作的testing，比如数据库连接，文件打开，REST服务登陆等
如果没有在TestMain中调用m.Run()，则除了TestMain意外的其他tests都不会被执行
go test遇到的一些问题-command-line-arguments undefined: xxxxx</description>
    </item>
    
    <item>
      <title>WebSocket</title>
      <link>https://antoniodc-aaa.github.io/post/%E5%85%B6%E4%BB%96/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-websockets/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://antoniodc-aaa.github.io/post/%E5%85%B6%E4%BB%96/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-websockets/</guid>
      <description>第三方库-WebSockets From GoDoc 概述 The Conn type represents a WebSocket connection.</description>
    </item>
    
    <item>
      <title>切片</title>
      <link>https://antoniodc-aaa.github.io/post/%E8%AF%AD%E8%A8%80/%E5%88%87%E7%89%87/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://antoniodc-aaa.github.io/post/%E8%AF%AD%E8%A8%80/%E5%88%87%E7%89%87/</guid>
      <description>Slice slice的内部结构 其实slice在Go的运行时库中就是一个C语言动态数组的实现，在$GOROOT/src/pkg/runtime/runtime.h中可以看到它的定义：
struct Slice { // must not move anything byte* array; // actual data uintgo len; // number of elements uintgo cap; // allocated number of elements }; 这个结构有3个字段，第一个字段表示array的指针，就是真实数据的指针（这个一定要注意），所以才经常说slice是数组的引用，第二个是表示slice的长度，第三个是表示slice的容量，注意：*len和cap都不是指针*。</description>
    </item>
    
    <item>
      <title>前后端交互</title>
      <link>https://antoniodc-aaa.github.io/post/%E5%85%B6%E4%BB%96/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E5%90%8E%E7%AB%AF%E4%B8%8E%E5%89%8D%E7%AB%AF%E7%9A%84%E9%A1%B5%E9%9D%A2%E4%BA%A4%E4%BA%92/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://antoniodc-aaa.github.io/post/%E5%85%B6%E4%BB%96/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E5%90%8E%E7%AB%AF%E4%B8%8E%E5%89%8D%E7%AB%AF%E7%9A%84%E9%A1%B5%E9%9D%A2%E4%BA%A4%E4%BA%92/</guid>
      <description>Go语言后端与前端的页面交互 通过表单 ​	GET与POST的区别
​	1&amp;gt;GET请求消息体为空，POST请求带有消息体、
​	2&amp;gt;GET提交的数据会放在URL之后，以？分割URL和传输数据，参数之间以&amp;amp;相连
​	3&amp;gt;GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST对提交的数据没有限制</description>
    </item>
    
    <item>
      <title>协程</title>
      <link>https://antoniodc-aaa.github.io/post/%E8%AF%AD%E8%A8%80/goroutine/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://antoniodc-aaa.github.io/post/%E8%AF%AD%E8%A8%80/goroutine/</guid>
      <description>协程Goroutine 轻量级“线程”
非抢占式多任务处理，由协程主动交出控制权
编译器/解释器/虚拟机层面的多任务
多个协程可能在一个或多个线程上运行
抢占式多任务会造成卡死的情况，这时需要：
1.做IO操作会交出控制权
2.runtime.Gosched()手动交出控制权
goroutine可能的切换点
 I/O ,select Channel 等待锁 函数调用（有时候） runtime.</description>
    </item>
    
    <item>
      <title>发布订阅模式</title>
      <link>https://antoniodc-aaa.github.io/post/%E5%85%B6%E4%BB%96/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://antoniodc-aaa.github.io/post/%E5%85%B6%E4%BB%96/go%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>发布订阅模式 观察者模式又叫作发布订阅模式，属于设计模式中行为模式中的一种。
发布订阅（publish-and-subscribe）模型同城被简写为pub/sub模型。在这个模型中，消息生产者成为发布者（publisher），二消息消费者则成为订阅者（subscriber），生产者和消费者是M:N的关系。在传统生产者和消费者模型中，是将消息发送到一个队列中，二发布订阅模型则是将消息发布给一个主题。
​	为此，我们构建一个名为pubsub	的发布订阅模型支持包：
import ( &amp;#34;sync&amp;#34; &amp;#34;time&amp;#34; ) type ( subscriber chan interface{} //订阅者为一个管道 	topicFunc func(v interface{}) bool //主题为一个过滤器 ) //发布者对象 type Publisher struct { m sync.</description>
    </item>
    
    <item>
      <title>并发的非阻塞缓存</title>
      <link>https://antoniodc-aaa.github.io/post/%E5%85%B6%E4%BB%96/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/%E5%B9%B6%E5%8F%91%E7%9A%84%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%BC%93%E5%AD%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://antoniodc-aaa.github.io/post/%E5%85%B6%E4%BB%96/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/%E5%B9%B6%E5%8F%91%E7%9A%84%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%BC%93%E5%AD%98/</guid>
      <description>并发的非阻塞缓存 博客地址：https://cloud.tencent.com/developer/article/1501662
个人理解：这是做了一个网络爬虫，爬取网页，然后打印
设计并发，不重复，无阻塞cache
1.并发：go func(){}()直接启动新的goroutine来实现
2.并发安全：使用sysnc.Mutex互斥锁来实现
3.无阻塞：get之前锁定，赋值一个入口指针后立马解锁，然后进行http请求，这样不会被慢的http请求阻塞住
4.不重复：利用channel，多个并发同时写的时候，利用channel阻塞住，等第一个请求写完后关闭channel，其他goroutine直接请求
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;golang.</description>
    </item>
    
    <item>
      <title>接口</title>
      <link>https://antoniodc-aaa.github.io/post/%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://antoniodc-aaa.github.io/post/%E8%AF%AD%E8%A8%80/go%E8%AF%AD%E8%A8%80%E6%8E%A5%E5%8F%A3/</guid>
      <description>Go语言接口 Go语言中，接口类型具体描述了一系列方法的集合，一个实现了接口所包含的方法的具体类型是这个接口的实例
与传统的面向对象不同，接口是由使用者定义的
接口的动态类型：接口绑定的具体实例的类型称为接口的动态类型。接口可以绑定不同类型的势力，所以接口的动态类型是随着绑定的不同类型示例代码而发生变化的
接口值由两部分组成，一个具体的类型是那个类型的值。他们称为接口的动态 类型和动态值。对于Go这种静态类型的语言，类型是编译期的概念；因此一个类型不是一个值。在概念模型中，提供类型信息的值被称为 类型描述符，比如类型的名称和方法。在一个接口值中，类型部分代表与之相关类型的描述符
接口值是可以用==和!=来进行比较的
接口赋值在GO语言中有两种情况
将对象实例赋值给接口</description>
    </item>
    
  </channel>
</rss>