<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Blog</title>
    <link>https://antoniodc-aaa.github.io/post/</link>
    <description>Recent content in Posts on Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 23 Mar 2020 12:58:03 +0800</lastBuildDate>
    
	<atom:link href="https://antoniodc-aaa.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>DLL</title>
      <link>https://antoniodc-aaa.github.io/post/dll/</link>
      <pubDate>Mon, 23 Mar 2020 12:58:03 +0800</pubDate>
      
      <guid>https://antoniodc-aaa.github.io/post/dll/</guid>
      <description>先测试测试呢</description>
    </item>
    
    <item>
      <title>Git instructions</title>
      <link>https://antoniodc-aaa.github.io/post/git/</link>
      <pubDate>Tue, 18 Feb 2020 18:02:14 +0800</pubDate>
      
      <guid>https://antoniodc-aaa.github.io/post/git/</guid>
      <description>Git 集中式版本控制系统与分布式版本控制系统 集中式版本控制系统
​	有一个包含文件所有修订版本的单一服务器，多个客户端可以从这个中心位置检索出文件
优点：所有人都可以在一定程度上掌握其他人在项目中做了什么，管理员可以精细的掌控每个人的权限，
缺点：集中式服务器带来的单点故障
分布式版本控制系统
​	客户端并非仅仅是检出文件的最新快照，而是对代码仓库进行完整的镜像，不管是那个服务器出现故障，任何一个客户端都可以使用自己的本地镜像来恢复服务器，每一次检出操作实际上都是对数据的一次完整备份。</description>
    </item>
    
    <item>
      <title>线程池和无锁队列实现并发</title>
      <link>https://antoniodc-aaa.github.io/post/%E5%B9%B6%E5%8F%91/</link>
      <pubDate>Sat, 18 Jan 2020 18:18:08 +0800</pubDate>
      
      <guid>https://antoniodc-aaa.github.io/post/%E5%B9%B6%E5%8F%91/</guid>
      <description>通过一个在项目中使用的服务器编程的例子，记录一下怎样通过线程池和原子操作实现并发编程 原始模型是：一个生产者，一个缓存队列，两个消费者，一个条件变量。 线程池模型是：线程池中的线程做生产者，分别绑定一个缓存队列，每个缓存队列绑定两个消费者 工作过程：线程池中的线程将数据写入自己绑定的队列中，当缓存到达一半时，使用条件变量唤醒两个消费者，迅速将数据消费完 缓存队列的读写指针，使用C++11的原子变量，保证两个写者之间的同步。
#define pack_max 512*1024*1024struct myatomic { atomic_int rd; atomic_int wd: }; struct myCmd { int cmd; char buf[50]; string ip; }; //共享变量 myatomic ato_rw1{0,0}; myCmd Buffer1[pack_max]; //生产者 void creator(string ip,int fd) { char buf1[50]; read(fd,buf1,len); myCmd inbuf; //填充inbuf 	//.</description>
    </item>
    
    <item>
      <title>sorts</title>
      <link>https://antoniodc-aaa.github.io/post/sorts/</link>
      <pubDate>Sat, 18 May 2019 17:40:00 +0800</pubDate>
      
      <guid>https://antoniodc-aaa.github.io/post/sorts/</guid>
      <description>冒泡排序 每次外循环都能确定数组的最大值
func BubbleSort(nums []int){ if nums == nil || len(nums) &amp;lt; 2{ return } for i:=len(nums)-1;i&amp;gt;=0;i--{ for j:=0;j&amp;lt;i;j++{ if nums[j] &amp;gt; nums[j+1]{ nums[j],nums[j+1] = nums[j+1],nums[j] } } } fmt.</description>
    </item>
    
  </channel>
</rss>