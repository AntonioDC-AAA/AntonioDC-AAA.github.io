<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="generator" content="Hugo 0.65.0-DEV" />

  <title> &middot; Blog</title>

  <meta name="description" content="" />

  
  <meta property="og:locale" content="en-us"/>

  
  <meta property="og:image" content="https://antoniodc-aaa.github.io/images/name.jpg">

  
  <meta property="og:type" content="blog"/>
  <meta property="og:site_name" content="Blog"/><meta property="og:title" content=""/>
  <meta property="og:url" content="https://antoniodc-aaa.github.io/docker%E7%AE%80%E4%BB%8B/"/>
  <meta property="og:description" content="Docker Docker时一个开源的应用容器引擎它让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到安装了任何Linux发行版本的机器上。
Docker时直接运行在宿主操作系统上的一个容器，使用沙箱机制完全虚拟出一个完整的操作，容器之间不会有任何接口，从而让容器与宿主机之间、容器与容器之间的隔离更加彻底。每个容器都有自己的权限管理，独立的网络与存储栈，以及自己的资源管理能，使同一台宿主机上可以友好的共存多个容器
Docker能干什么   简化配置
虚拟机的最大好处是能在你的硬件设施上运行各种配置不一样的平台（软件、系统），Docker在降低额外开销的情况下提供了同样的功能。他能将运行环境和配置放在代码中然后部署，同一个docker的配置可以在不同的环境中使用，这样就降低了硬件要求和应用环境之间的耦合性
  代码流水线管理"/>

  <script type="application/ld+json">
  {
    "@context" : "http://schema.org",
    "@type" : "Blog",
    "name": "Blog",
    "url" : "https://antoniodc-aaa.github.io/",
    "image": "https://antoniodc-aaa.github.io/images/name.jpg",
    "description": "You only live once !"
  }
  </script>

  


  <link type="text/css"
        rel="stylesheet"
        href="https://antoniodc-aaa.github.io/css/print.css"
        media="print">

  <link type="text/css"
        rel="stylesheet"
        href="https://antoniodc-aaa.github.io/css/poole.css">

  <link type="text/css"
        rel="stylesheet"
        href="https://antoniodc-aaa.github.io/css/hyde.css">

  
<style type="text/css">
  .sidebar {
    background-color: #fc21803;
  }

  .read-more-link a {
    border-color: #fc21803;
  }

  footer a,
  .content a,
  .related-posts li a:hover {
    color: #fc21803;
  }
</style>



  <link type="text/css" rel="stylesheet" href="https://antoniodc-aaa.github.io/css/blog.css">

  <link rel="stylesheet"
        href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700&display=swap">

  <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css"
        integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk="
        crossorigin="anonymous" />

  <link rel="apple-touch-icon-precomposed"
        sizes="144x144"
        href="/apple-touch-icon-144-precomposed.png">

  <link rel="shortcut icon" href="/favicon.png">

  
  </head>
<body>
  <aside class="sidebar">
  <div class="container">
    <div class="sidebar-about">
      
        
        <div class="author-image">
          <img src="https://antoniodc-aaa.github.io/images/name.jpg" class="img-circle img-headshot center" alt="Profile Picture">
        </div>
        
      

      <h1>Blog</h1>

      
      <p class="lead">You only live once !</p>
      
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li>
          <a href="https://antoniodc-aaa.github.io/">Home</a>
        </li>
        <li>
          <a href="/post/"> Posts </a>
        </li><li>
          <a href="/tags/"> Tags </a>
        </li><li>
          <a href="/about/"> About </a>
        </li>
      </ul>
    </nav>

    <section class="social-icons">
      
      <a href="https://github.com/" rel="me" title="GitHub">
        <i class="fab fa-github" aria-hidden="true"></i>
      </a>
      
      <a href="#" rel="me" title="Twitter">
        <i class="fab fa-twitter" aria-hidden="true"></i>
      </a>
      
    </section>
  </div>
</aside>


  <main class="content container">
  <div class="post">
  <h1></h1>

  

  <h1 id="docker">Docker</h1>
<p>Docker时一个开源的应用容器引擎它让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到安装了任何Linux发行版本的机器上。</p>
<p>Docker时直接运行在宿主操作系统上的一个容器，使用沙箱机制完全虚拟出一个完整的操作，容器之间不会有任何接口，从而让容器与宿主机之间、容器与容器之间的隔离更加彻底。每个容器都有自己的权限管理，独立的网络与存储栈，以及自己的资源管理能，使同一台宿主机上可以友好的共存多个容器</p>
<h2 id="docker能干什么">Docker能干什么</h2>
<ul>
<li>
<p>简化配置</p>
<p>虚拟机的最大好处是能在你的硬件设施上运行各种配置不一样的平台（软件、系统），Docker在降低额外开销的情况下提供了同样的功能。他能将运行环境和配置放在代码中然后部署，同一个docker的配置可以在不同的环境中使用，这样就降低了硬件要求和应用环境之间的耦合性</p>
</li>
<li>
<p>代码流水线管理</p>
<p>代码从开发者的机器到最终在生产环境上的部署，需要经过很多的中间环境。而每一个中间环境都有自己微小的差别，Docker给应用提供了一个从开发到上线均一致的环境，让代码的流水线变得简单不少。</p>
</li>
<li>
<p>提高开发效率</p>
</li>
<li>
<p>隔离应用</p>
<p>一是因为要降低成本而进行服务器整合，二是将一个整体式的应用拆分成松耦合的单个服务</p>
</li>
<li>
<p>整合服务器</p>
<p>通过虚拟机来整合多个应用，Docker隔离应用的能力使得Docker可以整合多个服务器以降低成本。</p>
</li>
<li>
<p>调适能力</p>
</li>
<li>
<p>多租户</p>
</li>
<li>
<p>快速部署</p>
<p>Docker只是创建一个容器进程而无需启动操作系统，这个过程只需要秒级的时间。</p>
</li>
</ul>
<h2 id="docker和虚拟机的区别">Docker和虚拟机的区别</h2>
<p>虚拟机与容器化技术都是虚拟化技术，两者的区别在于虚拟化程度不同</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702084931779.png" alt="image-20200702084931779"></p>
<h2 id="docker架构">Docker架构</h2>
<p>Docker使用客户端-服务器（C/S）架构模式，使用远程API来管理和创建Docker容器</p>
<p>Docker 客户端： Docker客户端通过命令行或者其他工具来使用Docker SDK与Docker的守护进程通信</p>
<p>Docker主机： 一个物理或者虚拟的机器用于执行Docker守护进程和容器</p>
<p>容器的状态有7种</p>
<ul>
<li>created（已创建）</li>
<li>restarting（重启中）</li>
<li>running（运行中）</li>
<li>removing（迁移中）</li>
<li>paused（暂停）</li>
<li>exited（停止）</li>
<li>dead（死亡）</li>
</ul>
<p>Docker在两个互联的容器之间创建一个安全隧道，而且不用映射它们的端口到宿主机上。在启动db容器的时候并没有使用-p和-P标记，从而避免了暴露数据库端口到外部网络上。</p>
<h3 id="容器公开连接信息">容器公开连接信息</h3>
<p>Docker通过两种方式为容器公开连接信息</p>
<ul>
<li>环境变量</li>
<li>更新/etc/hosts文件</li>
</ul>
<h2 id="单机中docker网络">单机中Docker网络</h2>
<h3 id="理解docker默认网桥">理解Docker默认网桥</h3>
<p>在你安装Docker服务默认会创建一个Docker0 网桥（其上有一个docker0 内部接口），它在内核层联通了其他的物理或者虚拟网卡，这就将所有容器和本地主机都放在同一个物理网络</p>
<h3 id="理解容器创建时的ip分配">理解容器创建时的IP分配</h3>
<p>Docker在创建一个容器时，会执行如下操作</p>
<ol>
<li>创建一对虚拟接口/网卡，也就是 veth pair，分别放到本地主机和新容器中</li>
<li>本地主机一端桥接到默认的docker0或指定网桥上，并具有一个的唯一的名字</li>
<li>容器一端放到新容器中，并修改名字作为eth0，这个网卡/接口只在容器的名字空间可见</li>
<li>从网桥可用地址（也就是与该bridge对应的network）中获取一个空闲地址分配给容器eth0,并配置默认路由到桥接网卡vethxxxxx</li>
</ol>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702093724660.png" alt="image-20200702093724660"></p>
<h2 id="多物理机之间互联">多物理机之间互联</h2>
<p>主机A和主机B的网卡一直连着物理交换机的同一个vlan 101，这样网桥一和网桥三就相当于在同一个物理网络中，而容器一、容器三、容器四也在同一个物理网络中，他们可以互相通信，可以跟同一vlan中的其他物理机互联</p>
<p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200702094045131.png" alt="image-20200702094045131"></p>
<h2 id="docker基础-docker数据卷和数据管理">Docker基础-Docker数据卷和数据管理</h2>
<p>数据卷的使用，类似于Linux下对目录或文件进行mount</p>
<p>数据卷的特性：</p>
<ol>
<li>数据卷可以在容器之间共享和宠用</li>
<li>对数据卷的修改会立马生效</li>
<li>对数据卷的更新，不会影响镜像</li>
<li>卷会一直存在，直到没有容器使用</li>
</ol>
<h3 id="数据卷容器">数据卷容器</h3>
<p>主机和容器之间可以共享数据。如果你有一些持续更新的数据需要在容之间共享，最好的办法就是创建数据卷容器。</p>
<p>数据卷容器，其实就是一个正常的容器，专门用来提供数据卷供其他容器挂载的</p>
<p>如果删除了挂载的容器，数据卷并不会自动删除。如果删除一个数据卷，必须在删除最后一个挂载着它的容器使用</p>
<p>docker rm -v命令来指定同时删除关联的容器。这可以让用户在容器之间升级和移动数据卷</p>
<p>数据备份、恢复、迁移数据卷</p>
<p>可以利用数据卷对其中的数据进行备份、恢复和迁移</p>

</div>


  </main>

  <footer>
  <div class="copyright">
    &copy; Antonio.D.C 2020 · <a href="https://creativecommons.org/licenses/by-sa/4.0">CC BY-SA 4.0</a>
  </div>
</footer>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/js/all.min.js"
          integrity="sha256-MAgcygDRahs+F/Nk5Vz387whB4kSK9NXlDN3w58LLq0="
          crossorigin="anonymous"></script>

  <script src="https://antoniodc-aaa.github.io/js/blog.js"></script>

  
</body>
</html>
